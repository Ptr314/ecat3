AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6108 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0000 =                  ROM_vectors = 0
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0000 =                  I_flag = 0
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
000a =                          org zero_page
                        ;break test interrupt save
000a : 00               irq_a   ds  1               ;a register
000b : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c :                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c : 00               adfc    ds  1               ;carry flag before op
000d : 00               ad1     ds  1               ;operand 1 - accumulator
000e : 00               ad2     ds  1               ;operand 2 - memory / immediate
000f : 00               adrl    ds  1               ;expected result bits 0-7
0010 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0011 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0013 :                  zp_bss
0013 : 8001             zps     db  $80,1           ;additional shift pattern to test zero result & flag
0015 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0019 : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
001a : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001e : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0022 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0026 : 1802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0028 : 1902                     dw  abs1+1
002a : 1a02                     dw  abs1+2
002c : 1b02                     dw  abs1+3
002e : 1c02                     dw  abs7f
0030 : 2001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0032 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0034 : 0402                     dw  abst+1
0036 : 0502                     dw  abst+2
0038 : 0602                     dw  abst+3
003a : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003c : 5f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003e : 6002                     dw  absAN+1
0040 : 6102                     dw  absAN+2
0042 : 6202                     dw  absAN+3
0044 : 6302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0046 : 6402                     dw  absEO+1
0048 : 6502                     dw  absEO+2
004a : 6602                     dw  absEO+3
004c : 5b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004e : 5c02                     dw  absOR+1
0050 : 5d02                     dw  absOR+2
0052 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
0054 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0056 : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0058 : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
005a : 0501             sbiy2   dw  sba2-$ff
005c :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;6 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 00000000                 ds  4               ;fill remaining bytes
0209 :                  data_bss
                            if load_data_direct = 1
0209 : 2900             ex_andi and #0              ;execute immediate opcodes
020b : 60                       rts
020c : 4900             ex_eori eor #0              ;execute immediate opcodes
020e : 60                       rts
020f : 0900             ex_orai ora #0              ;execute immediate opcodes
0211 : 60                       rts
0212 : 6900             ex_adci adc #0              ;execute immediate opcodes
0214 : 60                       rts
0215 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0217 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d : 80800002         fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 :                  rASL                                ;expected result ASL & ROL -carry
0221 : 000286048200     rROL    db  0,2,$86,$04,$82,0
0227 : 010387058301     rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d :                  rLSR                                ;expected result LSR & ROR -carry
022d : 400061412000     rROR    db  $40,0,$61,$41,$20,0
0233 : c080e1c1a080     rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 :                  fASL                                ;expected flags for shifts
0239 : 030081018002     fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f : 010081018000     fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 :                  fLSR 
0245 : 000301000102     fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b : 808181808180     fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 : 0080800200       fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b : 001f7180         absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 : 00f11f00         absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0277 : 02800080         absflo  db  fz,fn,0,fn
027b :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0438 : ad0002          >            lda test_case   ;previous test
043b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
043f : a901            >            lda #test_num   ;*** next tests' number
0441 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0444 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0446 :                  range_loop
0446 : 88                       dey             ;next relative address
0447 : 98                       tya
0448 : aa                       tax             ;precharge count to end of loop
0449 : 1008                     bpl range_fw    ;calculate relative address
044b : 18                       clc             ;avoid branch self or to relative address of branch
044c : 6902                     adc #2
044e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
044f : ea                       nop
0450 : ea                       nop
0451 : ea                       nop
0452 : ea                       nop
0453 :                  range_fw
0453 : ea                       nop
0454 : ea                       nop
0455 : ea                       nop
0456 : ea                       nop
0457 : ea                       nop
0458 : 497f                     eor #$7f        ;complement except sign
045a : 8de604                   sta range_adr   ;load into test target
045d : a900                     lda #0          ;should set zero flag in status register
045f : 4ce504                   jmp range_op
                                
0462 : ca                       dex             ; offset landing zone - backward branch too far
0463 : ca                       dex
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
                                ;relative address target field with branch under test in the middle
0467 : ca                       dex             ;-128 - max backward
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex             ;-120
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex             ;-110
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex             ;-100
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex             ;-90
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex             ;-80
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex             ;-70
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex             ;-60
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex             ;-50
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex             ;-40
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex             ;-30
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex             ;-20
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex             ;-10
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex             ;-3
04e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04e6 =                  range_adr   = *+1       ;modifiable relative address
04e5 : f03e                     beq *+64        ;+64 if called without modification
04e7 : ca                       dex             ;+0
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex             ;+10
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex             ;+20
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex             ;+30
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex             ;+40
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex             ;+50
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex             ;+60
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex             ;+70
052e : ca                       dex
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex             ;+80
0538 : ca                       dex
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex             ;+90
0542 : ca                       dex
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex             ;+100
054c : ca                       dex
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex             ;+110
0556 : ca                       dex
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex             ;+120
0560 : ca                       dex
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ea                       nop             ;offset landing zone - forward branch too far
0567 : ea                       nop
0568 : ea                       nop
0569 : ea                       nop
056a : ea                       nop
056b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
056d : 4c6d05          >        jmp *           ;failed anyway
                        
0570 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0571 : ea                       nop
0572 : ea                       nop
0573 : ea                       nop
0574 : ea                       nop
0575 :                  range_ok
0575 : ea                       nop
0576 : ea                       nop
0577 : ea                       nop
0578 : ea                       nop
0579 : ea                       nop
057a : c000                     cpy #0
057c : f003                     beq range_end   
057e : 4c4604                   jmp range_loop
0581 :                  range_end               ;range test successful
                            endif
                                next_test
0581 : ad0002          >            lda test_case   ;previous test
0584 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0586 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0588 : a902            >            lda #test_num   ;*** next tests' number
058a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
058d : c001                     cpy #1          ;testing BNE true
058f : d003                     bne test_bne
                                trap 
0591 : 4c9105          >        jmp *           ;failed anyway
                        
0594 :                  test_bne
0594 : a900                     lda #0 
0596 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
0598 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
059a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
059c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
059e : c901                     cmp #1
                                trap_eq 
05a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05a4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05a6 : aa                       tax 
05a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05ad : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05af : e001                     cpx #1
                                trap_eq 
05b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05b5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05b7 : a8                       tay 
05b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05be : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05c0 : c001                     cpy #1
                                trap_eq 
05c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05c8 : ad0002          >            lda test_case   ;previous test
05cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05cf : a903            >            lda #test_num   ;*** next tests' number
05d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05d4 : a2ff                     ldx #$ff        ;initialize stack
05d6 : 9a                       txs
05d7 : a955                     lda #$55
05d9 : 48                       pha
05da : a9aa                     lda #$aa
05dc : 48                       pha
05dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e2 : ba                       tsx
05e3 : 8a                       txa             ;overwrite accu
05e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e8 : 68                       pla
05e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ed : 68                       pla
05ee : c955                     cmp #$55
                                trap_ne
05f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f7 : ba                       tsx
05f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05fc : ad0002          >            lda test_case   ;previous test
05ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0601 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0603 : a904            >            lda #test_num   ;*** next tests' number
0605 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0608 : a9fb            >            lda #$ff    &m8i         ;force enable interrupts (mask I)
                       >
060a : 48              >            pha         ;use stack to load status
060b : 28              >            plp
                        
060c : 101a                     bpl nbr1        ;branches should not be taken
060e : 501b                     bvc nbr2
0610 : 901c                     bcc nbr3
0612 : d01d                     bne nbr4
0614 : 3003                     bmi br1         ;branches should be taken
                                trap 
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 : 7003             br1     bvs br2
                                trap 
061b : 4c1b06          >        jmp *           ;failed anyway
                        
061e : b003             br2     bcs br3
                                trap 
0620 : 4c2006          >        jmp *           ;failed anyway
                        
0623 : f00f             br3     beq br4
                                trap 
0625 : 4c2506          >        jmp *           ;failed anyway
                        
0628 :                  nbr1
                                trap            ;previous bpl taken 
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b :                  nbr2
                                trap            ;previous bvc taken
062b : 4c2b06          >        jmp *           ;failed anyway
                        
062e :                  nbr3
                                trap            ;previous bcc taken
062e : 4c2e06          >        jmp *           ;failed anyway
                        
0631 :                  nbr4
                                trap            ;previous bne taken
0631 : 4c3106          >        jmp *           ;failed anyway
                        
0634 : 08               br4     php
0635 : ba                       tsx
0636 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0638 : d0fe            >        bne *           ;failed not equal (non zero)
                        
063a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
063b : c9fb            >            cmp #($ff    |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
063d : d0fe            >        bne *           ;failed not equal (non zero)
                        
063f : ba                       tsx
0640 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0642 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0644 : a900            >            lda #0      &m8i         ;force enable interrupts (mask I)
                       >
0646 : 48              >            pha         ;use stack to load status
0647 : 28              >            plp
                        
0648 : 301a                     bmi nbr11       ;branches should not be taken
064a : 701b                     bvs nbr12
064c : b01c                     bcs nbr13
064e : f01d                     beq nbr14
0650 : 1003                     bpl br11        ;branches should be taken
                                trap 
0652 : 4c5206          >        jmp *           ;failed anyway
                        
0655 : 5003             br11    bvc br12
                                trap 
0657 : 4c5706          >        jmp *           ;failed anyway
                        
065a : 9003             br12    bcc br13
                                trap 
065c : 4c5c06          >        jmp *           ;failed anyway
                        
065f : d00f             br13    bne br14
                                trap 
0661 : 4c6106          >        jmp *           ;failed anyway
                        
0664 :                  nbr11
                                trap            ;previous bmi taken 
0664 : 4c6406          >        jmp *           ;failed anyway
                        
0667 :                  nbr12
                                trap            ;previous bvs taken 
0667 : 4c6706          >        jmp *           ;failed anyway
                        
066a :                  nbr13
                                trap            ;previous bcs taken 
066a : 4c6a06          >        jmp *           ;failed anyway
                        
066d :                  nbr14
                                trap            ;previous beq taken 
066d : 4c6d06          >        jmp *           ;failed anyway
                        
0670 : 08               br14    php
0671 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0672 : c930            >            cmp #(0      |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0674 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0676 : a902            >            lda #zero&m8i         ;force enable interrupts (mask I)
                       >
0678 : 48              >            pha         ;use stack to load status
0679 : 28              >            plp
                        
067a : d002                     bne brzs1
067c : f003                     beq brzs2
067e :                  brzs1
                                trap            ;branch zero/non zero
067e : 4c7e06          >        jmp *           ;failed anyway
                        
0681 : b002             brzs2   bcs brzs3
0683 : 9003                     bcc brzs4
0685 :                  brzs3
                                trap            ;branch carry/no carry
0685 : 4c8506          >        jmp *           ;failed anyway
                        
0688 : 3002             brzs4   bmi brzs5
068a : 1003                     bpl brzs6
068c :                  brzs5
                                trap            ;branch minus/plus
068c : 4c8c06          >        jmp *           ;failed anyway
                        
068f : 7002             brzs6   bvs brzs7
0691 : 5003                     bvc brzs8
0693 :                  brzs7
                                trap            ;branch overflow/no overflow
0693 : 4c9306          >        jmp *           ;failed anyway
                        
0696 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0696 : a901            >            lda #carry&m8i         ;force enable interrupts (mask I)
                       >
0698 : 48              >            pha         ;use stack to load status
0699 : 28              >            plp
                        
069a : f002                     beq brcs1
069c : d003                     bne brcs2
069e :                  brcs1
                                trap            ;branch zero/non zero
069e : 4c9e06          >        jmp *           ;failed anyway
                        
06a1 : 9002             brcs2   bcc brcs3
06a3 : b003                     bcs brcs4
06a5 :                  brcs3
                                trap            ;branch carry/no carry
06a5 : 4ca506          >        jmp *           ;failed anyway
                        
06a8 : 3002             brcs4   bmi brcs5
06aa : 1003                     bpl brcs6
06ac :                  brcs5
                                trap            ;branch minus/plus
06ac : 4cac06          >        jmp *           ;failed anyway
                        
06af : 7002             brcs6   bvs brcs7
06b1 : 5003                     bvc brcs8
06b3 :                  brcs7
                                trap            ;branch overflow/no overflow
06b3 : 4cb306          >        jmp *           ;failed anyway
                        
                        
06b6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06b6 : a980            >            lda #minus&m8i         ;force enable interrupts (mask I)
                       >
06b8 : 48              >            pha         ;use stack to load status
06b9 : 28              >            plp
                        
06ba : f002                     beq brmi1
06bc : d003                     bne brmi2
06be :                  brmi1
                                trap            ;branch zero/non zero
06be : 4cbe06          >        jmp *           ;failed anyway
                        
06c1 : b002             brmi2   bcs brmi3
06c3 : 9003                     bcc brmi4
06c5 :                  brmi3
                                trap            ;branch carry/no carry
06c5 : 4cc506          >        jmp *           ;failed anyway
                        
06c8 : 1002             brmi4   bpl brmi5
06ca : 3003                     bmi brmi6
06cc :                  brmi5
                                trap            ;branch minus/plus
06cc : 4ccc06          >        jmp *           ;failed anyway
                        
06cf : 7002             brmi6   bvs brmi7
06d1 : 5003                     bvc brmi8
06d3 :                  brmi7
                                trap            ;branch overflow/no overflow
06d3 : 4cd306          >        jmp *           ;failed anyway
                        
06d6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06d6 : a940            >            lda #overfl&m8i         ;force enable interrupts (mask I)
                       >
06d8 : 48              >            pha         ;use stack to load status
06d9 : 28              >            plp
                        
06da : f002                     beq brvs1
06dc : d003                     bne brvs2
06de :                  brvs1
                                trap            ;branch zero/non zero
06de : 4cde06          >        jmp *           ;failed anyway
                        
06e1 : b002             brvs2   bcs brvs3
06e3 : 9003                     bcc brvs4
06e5 :                  brvs3
                                trap            ;branch carry/no carry
06e5 : 4ce506          >        jmp *           ;failed anyway
                        
06e8 : 3002             brvs4   bmi brvs5
06ea : 1003                     bpl brvs6
06ec :                  brvs5
                                trap            ;branch minus/plus
06ec : 4cec06          >        jmp *           ;failed anyway
                        
06ef : 5002             brvs6   bvc brvs7
06f1 : 7003                     bvs brvs8
06f3 :                  brvs7
                                trap            ;branch overflow/no overflow
06f3 : 4cf306          >        jmp *           ;failed anyway
                        
06f6 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06f6 : a9f9            >            lda #$ff-zero&m8i         ;force enable interrupts (mask I)
                       >
06f8 : 48              >            pha         ;use stack to load status
06f9 : 28              >            plp
                        
06fa : f002                     beq brzc1
06fc : d003                     bne brzc2
06fe :                  brzc1
                                trap            ;branch zero/non zero
06fe : 4cfe06          >        jmp *           ;failed anyway
                        
0701 : 9002             brzc2   bcc brzc3
0703 : b003                     bcs brzc4
0705 :                  brzc3
                                trap            ;branch carry/no carry
0705 : 4c0507          >        jmp *           ;failed anyway
                        
0708 : 1002             brzc4   bpl brzc5
070a : 3003                     bmi brzc6
070c :                  brzc5
                                trap            ;branch minus/plus
070c : 4c0c07          >        jmp *           ;failed anyway
                        
070f : 5002             brzc6   bvc brzc7
0711 : 7003                     bvs brzc8
0713 :                  brzc7
                                trap            ;branch overflow/no overflow
0713 : 4c1307          >        jmp *           ;failed anyway
                        
0716 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0716 : a9fa            >            lda #$ff-carry&m8i         ;force enable interrupts (mask I)
                       >
0718 : 48              >            pha         ;use stack to load status
0719 : 28              >            plp
                        
071a : d002                     bne brcc1
071c : f003                     beq brcc2
071e :                  brcc1
                                trap            ;branch zero/non zero
071e : 4c1e07          >        jmp *           ;failed anyway
                        
0721 : b002             brcc2   bcs brcc3
0723 : 9003                     bcc brcc4
0725 :                  brcc3
                                trap            ;branch carry/no carry
0725 : 4c2507          >        jmp *           ;failed anyway
                        
0728 : 1002             brcc4   bpl brcc5
072a : 3003                     bmi brcc6
072c :                  brcc5
                                trap            ;branch minus/plus
072c : 4c2c07          >        jmp *           ;failed anyway
                        
072f : 5002             brcc6   bvc brcc7
0731 : 7003                     bvs brcc8
0733 :                  brcc7
                                trap            ;branch overflow/no overflow
0733 : 4c3307          >        jmp *           ;failed anyway
                        
0736 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0736 : a97b            >            lda #$ff-minus&m8i         ;force enable interrupts (mask I)
                       >
0738 : 48              >            pha         ;use stack to load status
0739 : 28              >            plp
                        
073a : d002                     bne brpl1
073c : f003                     beq brpl2
073e :                  brpl1
                                trap            ;branch zero/non zero
073e : 4c3e07          >        jmp *           ;failed anyway
                        
0741 : 9002             brpl2   bcc brpl3
0743 : b003                     bcs brpl4
0745 :                  brpl3
                                trap            ;branch carry/no carry
0745 : 4c4507          >        jmp *           ;failed anyway
                        
0748 : 3002             brpl4   bmi brpl5
074a : 1003                     bpl brpl6
074c :                  brpl5
                                trap            ;branch minus/plus
074c : 4c4c07          >        jmp *           ;failed anyway
                        
074f : 5002             brpl6   bvc brpl7
0751 : 7003                     bvs brpl8
0753 :                  brpl7
                                trap            ;branch overflow/no overflow
0753 : 4c5307          >        jmp *           ;failed anyway
                        
0756 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0756 : a9bb            >            lda #$ff-overfl&m8i         ;force enable interrupts (mask I)
                       >
0758 : 48              >            pha         ;use stack to load status
0759 : 28              >            plp
                        
075a : d002                     bne brvc1
075c : f003                     beq brvc2
075e :                  brvc1
                                trap            ;branch zero/non zero
075e : 4c5e07          >        jmp *           ;failed anyway
                        
0761 : 9002             brvc2   bcc brvc3
0763 : b003                     bcs brvc4
0765 :                  brvc3
                                trap            ;branch carry/no carry
0765 : 4c6507          >        jmp *           ;failed anyway
                        
0768 : 1002             brvc4   bpl brvc5
076a : 3003                     bmi brvc6
076c :                  brvc5
                                trap            ;branch minus/plus
076c : 4c6c07          >        jmp *           ;failed anyway
                        
076f : 7002             brvc6   bvs brvc7
0771 : 5003                     bvc brvc8
0773 :                  brvc7
                                trap            ;branch overflow/no overflow
0773 : 4c7307          >        jmp *           ;failed anyway
                        
0776 :                  brvc8
                                next_test
0776 : ad0002          >            lda test_case   ;previous test
0779 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
077b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
077d : a905            >            lda #test_num   ;*** next tests' number
077f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0782 : a255                     ldx #$55        ;x & y protected
0784 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0786 : a9fb            >            lda #$ff     &m8i         ;force enable interrupts (mask I)
                       >
0788 : 48              >            pha         ;use stack to load status
0789 : a901            >            lda #1     ;precharge accu
078b : 28              >            plp
                        
078c : 48                       pha
                                tst_a 1,$ff
078d : 08              >            php         ;save flags
078e : c901            >            cmp #1     ;test result
                       >            trap_ne
0790 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0792 : 68              >            pla         ;load status
0793 : 48              >            pha
                       >            cmp_flag $ff
0794 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0796 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0798 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0799 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
079b : 48              >            pha         ;use stack to load status
079c : a900            >            lda #0     ;precharge accu
079e : 28              >            plp
                        
079f : 48                       pha
                                tst_a 0,0
07a0 : 08              >            php         ;save flags
07a1 : c900            >            cmp #0     ;test result
                       >            trap_ne
07a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a5 : 68              >            pla         ;load status
07a6 : 48              >            pha
                       >            cmp_flag 0
07a7 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ab : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07ac : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
07ae : 48              >            pha         ;use stack to load status
07af : a9ff            >            lda #$ff     ;precharge accu
07b1 : 28              >            plp
                        
07b2 : 48                       pha
                                tst_a $ff,$ff
07b3 : 08              >            php         ;save flags
07b4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b8 : 68              >            pla         ;load status
07b9 : 48              >            pha
                       >            cmp_flag $ff
07ba : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07be : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07bf : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
07c1 : 48              >            pha         ;use stack to load status
07c2 : a901            >            lda #1     ;precharge accu
07c4 : 28              >            plp
                        
07c5 : 48                       pha
                                tst_a 1,0
07c6 : 08              >            php         ;save flags
07c7 : c901            >            cmp #1     ;test result
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 68              >            pla         ;load status
07cc : 48              >            pha
                       >            cmp_flag 0
07cd : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07d2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
07d4 : 48              >            pha         ;use stack to load status
07d5 : a900            >            lda #0     ;precharge accu
07d7 : 28              >            plp
                        
07d8 : 48                       pha
                                tst_a 0,$ff
07d9 : 08              >            php         ;save flags
07da : c900            >            cmp #0     ;test result
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 68              >            pla         ;load status
07df : 48              >            pha
                       >            cmp_flag $ff
07e0 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07e4 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07e5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
07e7 : 48              >            pha         ;use stack to load status
07e8 : a9ff            >            lda #$ff     ;precharge accu
07ea : 28              >            plp
                        
07eb : 48                       pha
                                tst_a $ff,0
07ec : 08              >            php         ;save flags
07ed : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 68              >            pla         ;load status
07f2 : 48              >            pha
                       >            cmp_flag 0
07f3 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f7 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07f8 : a9fb            >            lda #$ff     &m8i         ;force enable interrupts (mask I)
                       >
07fa : 48              >            pha         ;use stack to load status
07fb : a900            >            lda #0     ;precharge accu
07fd : 28              >            plp
                        
07fe : 68                       pla
                                tst_a $ff,$ff-zero
07ff : 08              >            php         ;save flags
0800 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 68              >            pla         ;load status
0805 : 48              >            pha
                       >            cmp_flag $ff-zero
0806 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0808 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
080a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
080b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
080d : 48              >            pha         ;use stack to load status
080e : a9ff            >            lda #$ff     ;precharge accu
0810 : 28              >            plp
                        
0811 : 68                       pla
                                tst_a 0,zero
0812 : 08              >            php         ;save flags
0813 : c900            >            cmp #0     ;test result
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 68              >            pla         ;load status
0818 : 48              >            pha
                       >            cmp_flag zero
0819 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
081b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
081e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0820 : 48              >            pha         ;use stack to load status
0821 : a9fe            >            lda #$fe     ;precharge accu
0823 : 28              >            plp
                        
0824 : 68                       pla
                                tst_a 1,$ff-zero-minus
0825 : 08              >            php         ;save flags
0826 : c901            >            cmp #1     ;test result
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 68              >            pla         ;load status
082b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
082c : c979            >            cmp #($ff-zero-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
082e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0830 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0831 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0833 : 48              >            pha         ;use stack to load status
0834 : a900            >            lda #0     ;precharge accu
0836 : 28              >            plp
                        
0837 : 68                       pla
                                tst_a $ff,minus
0838 : 08              >            php         ;save flags
0839 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 68              >            pla         ;load status
083e : 48              >            pha
                       >            cmp_flag minus
083f : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0841 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0843 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0844 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0846 : 48              >            pha         ;use stack to load status
0847 : a9ff            >            lda #$ff     ;precharge accu
0849 : 28              >            plp
                        
084a : 68                       pla
                                tst_a 0,$ff-minus
084b : 08              >            php         ;save flags
084c : c900            >            cmp #0     ;test result
                       >            trap_ne
084e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0850 : 68              >            pla         ;load status
0851 : 48              >            pha
                       >            cmp_flag $ff-minus
0852 : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0854 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0856 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0857 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0859 : 48              >            pha         ;use stack to load status
085a : a9fe            >            lda #$fe     ;precharge accu
085c : 28              >            plp
                        
085d : 68                       pla
                                tst_a 1,0
085e : 08              >            php         ;save flags
085f : c901            >            cmp #1     ;test result
                       >            trap_ne
0861 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0863 : 68              >            pla         ;load status
0864 : 48              >            pha
                       >            cmp_flag 0
0865 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0867 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0869 : 28              >            plp         ;restore status
                        
086a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
086c : d0fe            >        bne *           ;failed not equal (non zero)
                        
086e : c0aa                     cpy #$aa
                                trap_ne
0870 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0872 : ad0002          >            lda test_case   ;previous test
0875 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0879 : a906            >            lda #test_num   ;*** next tests' number
087b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
087e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0880 : 48              >            pha         ;use stack to load status
0881 : a93c            >            lda #$3c     ;precharge accu
0883 : 28              >            plp
                        
0884 : 49c3                     eor #$c3
                                tst_a $ff,fn
0886 : 08              >            php         ;save flags
0887 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0889 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
088b : 68              >            pla         ;load status
088c : 48              >            pha
                       >            cmp_flag fn
088d : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
088f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0891 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0892 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0894 : 48              >            pha         ;use stack to load status
0895 : a9c3            >            lda #$c3     ;precharge accu
0897 : 28              >            plp
                        
0898 : 49c3                     eor #$c3
                                tst_a 0,fz
089a : 08              >            php         ;save flags
089b : c900            >            cmp #0     ;test result
                       >            trap_ne
089d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089f : 68              >            pla         ;load status
08a0 : 48              >            pha
                       >            cmp_flag fz
08a1 : c932            >            cmp #(fz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a5 : 28              >            plp         ;restore status
                        
                                next_test
08a6 : ad0002          >            lda test_case   ;previous test
08a9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08ad : a907            >            lda #test_num   ;*** next tests' number
08af : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08b2 : a224                     ldx #$24
08b4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08b6 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
08b8 : 48              >            pha         ;use stack to load status
08b9 : a918            >            lda #$18     ;precharge accu
08bb : 28              >            plp
                        
08bc : ea                       nop
                                tst_a $18,0
08bd : 08              >            php         ;save flags
08be : c918            >            cmp #$18     ;test result
                       >            trap_ne
08c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c2 : 68              >            pla         ;load status
08c3 : 48              >            pha
                       >            cmp_flag 0
08c4 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c8 : 28              >            plp         ;restore status
                        
08c9 : e024                     cpx #$24
                                trap_ne
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
08cd : c042                     cpy #$42
                                trap_ne
08cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d1 : a2db                     ldx #$db
08d3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08d5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
08d7 : 48              >            pha         ;use stack to load status
08d8 : a9e7            >            lda #$e7     ;precharge accu
08da : 28              >            plp
                        
08db : ea                       nop
                                tst_a $e7,$ff
08dc : 08              >            php         ;save flags
08dd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e1 : 68              >            pla         ;load status
08e2 : 48              >            pha
                       >            cmp_flag $ff
08e3 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e7 : 28              >            plp         ;restore status
                        
08e8 : e0db                     cpx #$db
                                trap_ne
08ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ec : c0bd                     cpy #$bd
                                trap_ne
08ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08f0 : ad0002          >            lda test_case   ;previous test
08f3 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08f7 : a908            >            lda #test_num   ;*** next tests' number
08f9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08fc : a900            >            lda #$0&m8i         ;force enable interrupts (mask I)
                       >
08fe : 48              >            pha         ;use stack to load status
08ff : 28              >            plp
                        
0900 : a946                     lda #'F'
0902 : a241                     ldx #'A'
0904 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0906 : 4caf34                   jmp test_far
0909 : ea                       nop
090a : ea                       nop
                                trap_ne         ;runover protection
090b : d0fe            >        bne *           ;failed not equal (non zero)
                        
090d : e8                       inx
090e : e8                       inx
090f :                  far_ret 
                                trap_eq         ;returned flags OK?
090f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0911 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0913 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0915 : 50fe            >        bvc *           ;failed overflow clear
                        
0917 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
0919 : d0fe            >        bne *           ;failed not equal (non zero)
                        
091b : e042                     cpx #('A'+1)
                                trap_ne
091d : d0fe            >        bne *           ;failed not equal (non zero)
                        
091f : c04f                     cpy #('R'-3)
                                trap_ne
0921 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0923 : ca                       dex
0924 : c8                       iny
0925 : c8                       iny
0926 : c8                       iny
0927 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
0929 : 4c3209                   jmp test_near
092c : ea                       nop
092d : ea                       nop
                                trap_ne         ;runover protection
092e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0930 : e8                       inx
0931 : e8                       inx
0932 :                  test_near
                                trap_eq         ;passed flags OK?
0932 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0934 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0936 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0938 : 50fe            >        bvc *           ;failed overflow clear
                        
093a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
093c : d0fe            >        bne *           ;failed not equal (non zero)
                        
093e : e041                     cpx #'A'
                                trap_ne
0940 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0942 : c052                     cpy #'R'
                                trap_ne
0944 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0946 : ad0002          >            lda test_case   ;previous test
0949 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
094b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
094d : a909            >            lda #test_num   ;*** next tests' number
094f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0952 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0954 : 48              >            pha         ;use stack to load status
0955 : 28              >            plp
                        
0956 : a949                     lda #'I'
0958 : a24e                     ldx #'N'
095a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
095c : 6cde34                   jmp (ptr_tst_ind)
095f : ea                       nop
                                trap_ne         ;runover protection
0960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0962 : 88                       dey
0963 : 88                       dey
0964 :                  ind_ret 
0964 : 08                       php             ;either SP or Y count will fail, if we do not hit
0965 : 88                       dey
0966 : 88                       dey
0967 : 88                       dey
0968 : 28                       plp
                                trap_eq         ;returned flags OK?
0969 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
096b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
096d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
096f : 50fe            >        bvc *           ;failed overflow clear
                        
0971 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0975 : e04f                     cpx #('N'+1)
                                trap_ne
0977 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0979 : c03e                     cpy #('D'-6)
                                trap_ne
097b : d0fe            >        bne *           ;failed not equal (non zero)
                        
097d : ba                       tsx             ;SP check
097e : e0ff                     cpx #$ff
                                trap_ne
0980 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0982 : ad0002          >            lda test_case   ;previous test
0985 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0987 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
0989 : a90a            >            lda #test_num   ;*** next tests' number
098b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
098e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0990 : 48              >            pha         ;use stack to load status
0991 : 28              >            plp
                        
0992 : a94a                     lda #'J'
0994 : a253                     ldx #'S'
0996 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0998 : 201d35                   jsr test_jsr
099a =                  jsr_ret = *-1           ;last address of jsr = return address
099b : 08                       php             ;either SP or Y count will fail, if we do not hit
099c : 88                       dey
099d : 88                       dey
099e : 88                       dey
099f : 28                       plp
                                trap_eq         ;returned flags OK?
09a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09a2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09a4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09a6 : 50fe            >        bvc *           ;failed overflow clear
                        
09a8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ac : e054                     cpx #('S'+1)
                                trap_ne
09ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b0 : c04c                     cpy #('R'-6)
                                trap_ne
09b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b4 : ba                       tsx             ;sp?
09b5 : e0ff                     cpx #$ff
                                trap_ne
09b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09b9 : ad0002          >            lda test_case   ;previous test
09bc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09c0 : a90b            >            lda #test_num   ;*** next tests' number
09c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                brk
                            else
09c5 : a909                     lda #hi brk_ret0 ;emulated break
09c7 : 48                       pha
09c8 : a9dc                     lda #lo brk_ret0
09ca : 48                       pha
                                load_flag fao    ;set break & unused on stack
09cb : a930            >            lda #fao    &m8i         ;force enable interrupts (mask I)
                        
09cd : 48                       pha
                                load_flag intdis ;during interrupt
09ce : a900            >            lda #intdis &m8i         ;force enable interrupts (mask I)
                        
09d0 : 48                       pha
09d1 : a942                     lda #'B'
09d3 : a252                     ldx #'R'
09d5 : a04b                     ldy #'K'
09d7 : 28                       plp             ;N=0, V=0, Z=0, C=0
09d8 : 4c6b35                   jmp irq_trap
                            endif
09db : 88                       dey             ;should not be executed
09dc :                  brk_ret0                ;address of break return
09dc : 08                       php             ;either SP or Y count will fail, if we do not hit
09dd : 88                       dey
09de : 88                       dey
09df : 88                       dey
09e0 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
09e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e4 : e053                     cpx #'R'+1
                                trap_ne
09e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e8 : c045                     cpy #'K'-6
                                trap_ne
09ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ec : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
09ed : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
09ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
09f1 : ba                       tsx             ;sp?
09f2 : e0ff                     cpx #$ff
                                trap_ne
09f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
                                pha
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                brk
                            else
09f6 : a90a                     lda #hi brk_ret1 ;emulated break
09f8 : 48                       pha
09f9 : a90b                     lda #lo brk_ret1
09fb : 48                       pha
                                load_flag $ff
09fc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
09fe : 48                       pha             ;set break & unused on stack
09ff : 48                       pha             ;actual flags
0a00 : a9bd                     lda #$ff-'B'
0a02 : a2ad                     ldx #$ff-'R'
0a04 : a0b4                     ldy #$ff-'K'
0a06 : 28                       plp             ;N=1, V=1, Z=1, C=1
0a07 : 4c6b35                   jmp irq_trap
                            endif
0a0a : 88                       dey             ;should not be executed
0a0b :                  brk_ret1                ;address of break return
0a0b : 08                       php             ;either SP or Y count will fail, if we do not hit
0a0c : 88                       dey
0a0d : 88                       dey
0a0e : 88                       dey
0a0f : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a13 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0a15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a17 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0a19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a1b : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0a1c : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0a1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a20 : ba                       tsx             ;sp?
0a21 : e0ff                     cpx #$ff
                                trap_ne
0a23 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a25 : ad0002          >            lda test_case   ;previous test
0a28 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0a2c : a90c            >            lda #test_num   ;*** next tests' number
0a2e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0a31 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0a33 : 48              >            pha         ;use stack to load status
0a34 : 28              >            plp
                        
0a35 : 18                       clc
                                tst_stat $ff-carry
0a36 : 08              >            php         ;save status
0a37 : 68              >            pla         ;use stack to retrieve status
0a38 : 48              >            pha
                       >            cmp_flag $ff-carry
0a39 : c9fa            >            cmp #($ff-carry|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3d : 28              >            plp         ;restore status
                        
0a3e : 38                       sec
                                tst_stat $ff
0a3f : 08              >            php         ;save status
0a40 : 68              >            pla         ;use stack to retrieve status
0a41 : 48              >            pha
                       >            cmp_flag $ff
0a42 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a46 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                cli
                                tst_stat $ff-intdis
                                sei
                                tst_stat $ff
                            endif
0a47 : d8                       cld
                                tst_stat $ff-decmode
0a48 : 08              >            php         ;save status
0a49 : 68              >            pla         ;use stack to retrieve status
0a4a : 48              >            pha
                       >            cmp_flag $ff-decmode
0a4b : c9f3            >            cmp #($ff-decmode|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a4f : 28              >            plp         ;restore status
                        
0a50 : f8                       sed
                                tst_stat $ff
0a51 : 08              >            php         ;save status
0a52 : 68              >            pla         ;use stack to retrieve status
0a53 : 48              >            pha
                       >            cmp_flag $ff
0a54 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a58 : 28              >            plp         ;restore status
                        
0a59 : b8                       clv
                                tst_stat $ff-overfl
0a5a : 08              >            php         ;save status
0a5b : 68              >            pla         ;use stack to retrieve status
0a5c : 48              >            pha
                       >            cmp_flag $ff-overfl
0a5d : c9bb            >            cmp #($ff-overfl|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a61 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a62 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0a64 : 48              >            pha         ;use stack to load status
0a65 : 28              >            plp
                        
                                tst_stat 0
0a66 : 08              >            php         ;save status
0a67 : 68              >            pla         ;use stack to retrieve status
0a68 : 48              >            pha
                       >            cmp_flag 0
0a69 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6d : 28              >            plp         ;restore status
                        
0a6e : 38                       sec
                                tst_stat carry
0a6f : 08              >            php         ;save status
0a70 : 68              >            pla         ;use stack to retrieve status
0a71 : 48              >            pha
                       >            cmp_flag carry
0a72 : c931            >            cmp #(carry|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a76 : 28              >            plp         ;restore status
                        
0a77 : 18                       clc
                                tst_stat 0  
0a78 : 08              >            php         ;save status
0a79 : 68              >            pla         ;use stack to retrieve status
0a7a : 48              >            pha
                       >            cmp_flag 0  
0a7b : c930            >            cmp #(0  |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7f : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                sei
                                tst_stat intdis
                                cli
                                tst_stat 0
                            endif  
0a80 : f8                       sed
                                tst_stat decmode
0a81 : 08              >            php         ;save status
0a82 : 68              >            pla         ;use stack to retrieve status
0a83 : 48              >            pha
                       >            cmp_flag decmode
0a84 : c938            >            cmp #(decmode|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a88 : 28              >            plp         ;restore status
                        
0a89 : d8                       cld
                                tst_stat 0  
0a8a : 08              >            php         ;save status
0a8b : 68              >            pla         ;use stack to retrieve status
0a8c : 48              >            pha
                       >            cmp_flag 0  
0a8d : c930            >            cmp #(0  |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a91 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a92 : a940            >            lda #overfl&m8i         ;force enable interrupts (mask I)
                       >
0a94 : 48              >            pha         ;use stack to load status
0a95 : 28              >            plp
                        
                                tst_stat overfl
0a96 : 08              >            php         ;save status
0a97 : 68              >            pla         ;use stack to retrieve status
0a98 : 48              >            pha
                       >            cmp_flag overfl
0a99 : c970            >            cmp #(overfl|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9d : 28              >            plp         ;restore status
                        
0a9e : b8                       clv
                                tst_stat 0
0a9f : 08              >            php         ;save status
0aa0 : 68              >            pla         ;use stack to retrieve status
0aa1 : 48              >            pha
                       >            cmp_flag 0
0aa2 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0aa4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa6 : 28              >            plp         ;restore status
                        
                                next_test
0aa7 : ad0002          >            lda test_case   ;previous test
0aaa : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0aac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0aae : a90d            >            lda #test_num   ;*** next tests' number
0ab0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0ab3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0ab5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0ab7 : 48              >            pha         ;use stack to load status
0ab8 : 28              >            plp
                        
0ab9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0aba : 08              >            php         ;save flags
0abb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0abd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0abf : 68              >            pla         ;load status
0ac0 : 48              >            pha
                       >            cmp_flag $ff-zero
0ac1 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ac3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac5 : 28              >            plp         ;restore status
                        
0ac6 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0ac7 : 08              >            php         ;save flags
0ac8 : e000            >            cpx #0     ;test result
                       >            trap_ne
0aca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acc : 68              >            pla         ;load status
0acd : 48              >            pha
                       >            cmp_flag $ff-minus
0ace : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ad0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad2 : 28              >            plp         ;restore status
                        
0ad3 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0ad4 : 08              >            php         ;save flags
0ad5 : e001            >            cpx #1     ;test result
                       >            trap_ne
0ad7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad9 : 68              >            pla         ;load status
0ada : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0adb : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0add : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0adf : 28              >            plp         ;restore status
                        
0ae0 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0ae1 : 08              >            php         ;save flags
0ae2 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ae4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae6 : 68              >            pla         ;load status
0ae7 : 48              >            pha
                       >            cmp_flag $ff-minus
0ae8 : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0aea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aec : 28              >            plp         ;restore status
                        
0aed : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0aee : 08              >            php         ;save flags
0aef : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0af1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af3 : 68              >            pla         ;load status
0af4 : 48              >            pha
                       >            cmp_flag $ff-zero
0af5 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0af7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af9 : 28              >            plp         ;restore status
                        
0afa : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0afb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0afd : 48              >            pha         ;use stack to load status
0afe : 28              >            plp
                        
0aff : e8                       inx             ;ff
                                tst_x $ff,minus
0b00 : 08              >            php         ;save flags
0b01 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b05 : 68              >            pla         ;load status
0b06 : 48              >            pha
                       >            cmp_flag minus
0b07 : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0b : 28              >            plp         ;restore status
                        
0b0c : e8                       inx             ;00
                                tst_x 0,zero
0b0d : 08              >            php         ;save flags
0b0e : e000            >            cpx #0     ;test result
                       >            trap_ne
0b10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b12 : 68              >            pla         ;load status
0b13 : 48              >            pha
                       >            cmp_flag zero
0b14 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b18 : 28              >            plp         ;restore status
                        
0b19 : e8                       inx             ;01
                                tst_x 1,0
0b1a : 08              >            php         ;save flags
0b1b : e001            >            cpx #1     ;test result
                       >            trap_ne
0b1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1f : 68              >            pla         ;load status
0b20 : 48              >            pha
                       >            cmp_flag 0
0b21 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b25 : 28              >            plp         ;restore status
                        
0b26 : ca                       dex             ;00
                                tst_x 0,zero
0b27 : 08              >            php         ;save flags
0b28 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2c : 68              >            pla         ;load status
0b2d : 48              >            pha
                       >            cmp_flag zero
0b2e : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b32 : 28              >            plp         ;restore status
                        
0b33 : ca                       dex             ;ff
                                tst_x $ff,minus
0b34 : 08              >            php         ;save flags
0b35 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b39 : 68              >            pla         ;load status
0b3a : 48              >            pha
                       >            cmp_flag minus
0b3b : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3f : 28              >            plp         ;restore status
                        
                        
0b40 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b42 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0b44 : 48              >            pha         ;use stack to load status
0b45 : 28              >            plp
                        
0b46 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b47 : 08              >            php         ;save flags
0b48 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4c : 68              >            pla         ;load status
0b4d : 48              >            pha
                       >            cmp_flag $ff-zero
0b4e : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b52 : 28              >            plp         ;restore status
                        
0b53 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b54 : 08              >            php         ;save flags
0b55 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b59 : 68              >            pla         ;load status
0b5a : 48              >            pha
                       >            cmp_flag $ff-minus
0b5b : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5f : 28              >            plp         ;restore status
                        
0b60 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b61 : 08              >            php         ;save flags
0b62 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b66 : 68              >            pla         ;load status
0b67 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b68 : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6c : 28              >            plp         ;restore status
                        
0b6d : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b6e : 08              >            php         ;save flags
0b6f : c000            >            cpy #0     ;test result
                       >            trap_ne
0b71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b73 : 68              >            pla         ;load status
0b74 : 48              >            pha
                       >            cmp_flag $ff-minus
0b75 : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b79 : 28              >            plp         ;restore status
                        
0b7a : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b7b : 08              >            php         ;save flags
0b7c : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b80 : 68              >            pla         ;load status
0b81 : 48              >            pha
                       >            cmp_flag $ff-zero
0b82 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b86 : 28              >            plp         ;restore status
                        
0b87 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b88 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0b8a : 48              >            pha         ;use stack to load status
0b8b : 28              >            plp
                        
0b8c : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b8d : 08              >            php         ;save flags
0b8e : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b92 : 68              >            pla         ;load status
0b93 : 48              >            pha
                       >            cmp_flag 0+minus
0b94 : c9b0            >            cmp #(0+minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b98 : 28              >            plp         ;restore status
                        
0b99 : c8                       iny             ;00
                                tst_y 0,zero
0b9a : 08              >            php         ;save flags
0b9b : c000            >            cpy #0     ;test result
                       >            trap_ne
0b9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9f : 68              >            pla         ;load status
0ba0 : 48              >            pha
                       >            cmp_flag zero
0ba1 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ba3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba5 : 28              >            plp         ;restore status
                        
0ba6 : c8                       iny             ;01
                                tst_y 1,0
0ba7 : 08              >            php         ;save flags
0ba8 : c001            >            cpy #1     ;test result
                       >            trap_ne
0baa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bac : 68              >            pla         ;load status
0bad : 48              >            pha
                       >            cmp_flag 0
0bae : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bb0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb2 : 28              >            plp         ;restore status
                        
0bb3 : 88                       dey             ;00
                                tst_y 0,zero
0bb4 : 08              >            php         ;save flags
0bb5 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb9 : 68              >            pla         ;load status
0bba : 48              >            pha
                       >            cmp_flag zero
0bbb : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbf : 28              >            plp         ;restore status
                        
0bc0 : 88                       dey             ;ff
                                tst_y $ff,minus
0bc1 : 08              >            php         ;save flags
0bc2 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc6 : 68              >            pla         ;load status
0bc7 : 48              >            pha
                       >            cmp_flag minus
0bc8 : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcc : 28              >            plp         ;restore status
                        
                                        
0bcd : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0bcf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0bd1 : 48              >            pha         ;use stack to load status
0bd2 : 28              >            plp
                        
0bd3 : 8a                       txa
                                tst_a $ff,$ff-zero
0bd4 : 08              >            php         ;save flags
0bd5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd9 : 68              >            pla         ;load status
0bda : 48              >            pha
                       >            cmp_flag $ff-zero
0bdb : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bdf : 28              >            plp         ;restore status
                        
0be0 : 08                       php
0be1 : e8                       inx             ;00
0be2 : 28                       plp
0be3 : 8a                       txa
                                tst_a 0,$ff-minus
0be4 : 08              >            php         ;save flags
0be5 : c900            >            cmp #0     ;test result
                       >            trap_ne
0be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be9 : 68              >            pla         ;load status
0bea : 48              >            pha
                       >            cmp_flag $ff-minus
0beb : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bef : 28              >            plp         ;restore status
                        
0bf0 : 08                       php
0bf1 : e8                       inx             ;01
0bf2 : 28                       plp
0bf3 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0bf4 : 08              >            php         ;save flags
0bf5 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bf7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf9 : 68              >            pla         ;load status
0bfa : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bfb : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bff : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c00 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0c02 : 48              >            pha         ;use stack to load status
0c03 : 28              >            plp
                        
0c04 : 8a                       txa
                                tst_a 1,0
0c05 : 08              >            php         ;save flags
0c06 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0a : 68              >            pla         ;load status
0c0b : 48              >            pha
                       >            cmp_flag 0
0c0c : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c10 : 28              >            plp         ;restore status
                        
0c11 : 08                       php
0c12 : ca                       dex             ;00
0c13 : 28                       plp
0c14 : 8a                       txa
                                tst_a 0,zero
0c15 : 08              >            php         ;save flags
0c16 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1a : 68              >            pla         ;load status
0c1b : 48              >            pha
                       >            cmp_flag zero
0c1c : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c20 : 28              >            plp         ;restore status
                        
0c21 : 08                       php
0c22 : ca                       dex             ;ff
0c23 : 28                       plp
0c24 : 8a                       txa
                                tst_a $ff,minus
0c25 : 08              >            php         ;save flags
0c26 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2a : 68              >            pla         ;load status
0c2b : 48              >            pha
                       >            cmp_flag minus
0c2c : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c30 : 28              >            plp         ;restore status
                        
                                                
0c31 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0c33 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0c35 : 48              >            pha         ;use stack to load status
0c36 : 28              >            plp
                        
0c37 : 98                       tya
                                tst_a $ff,$ff-zero
0c38 : 08              >            php         ;save flags
0c39 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3d : 68              >            pla         ;load status
0c3e : 48              >            pha
                       >            cmp_flag $ff-zero
0c3f : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c43 : 28              >            plp         ;restore status
                        
0c44 : 08                       php
0c45 : c8                       iny             ;00
0c46 : 28                       plp
0c47 : 98                       tya
                                tst_a 0,$ff-minus
0c48 : 08              >            php         ;save flags
0c49 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4d : 68              >            pla         ;load status
0c4e : 48              >            pha
                       >            cmp_flag $ff-minus
0c4f : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c53 : 28              >            plp         ;restore status
                        
0c54 : 08                       php
0c55 : c8                       iny             ;01
0c56 : 28                       plp
0c57 : 98                       tya
                                tst_a 1,$ff-minus-zero
0c58 : 08              >            php         ;save flags
0c59 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5d : 68              >            pla         ;load status
0c5e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c5f : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c63 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c64 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0c66 : 48              >            pha         ;use stack to load status
0c67 : 28              >            plp
                        
0c68 : 98                       tya
                                tst_a 1,0
0c69 : 08              >            php         ;save flags
0c6a : c901            >            cmp #1     ;test result
                       >            trap_ne
0c6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6e : 68              >            pla         ;load status
0c6f : 48              >            pha
                       >            cmp_flag 0
0c70 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c74 : 28              >            plp         ;restore status
                        
0c75 : 08                       php
0c76 : 88                       dey             ;00
0c77 : 28                       plp
0c78 : 98                       tya
                                tst_a 0,zero
0c79 : 08              >            php         ;save flags
0c7a : c900            >            cmp #0     ;test result
                       >            trap_ne
0c7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7e : 68              >            pla         ;load status
0c7f : 48              >            pha
                       >            cmp_flag zero
0c80 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c84 : 28              >            plp         ;restore status
                        
0c85 : 08                       php
0c86 : 88                       dey             ;ff
0c87 : 28                       plp
0c88 : 98                       tya
                                tst_a $ff,minus
0c89 : 08              >            php         ;save flags
0c8a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8e : 68              >            pla         ;load status
0c8f : 48              >            pha
                       >            cmp_flag minus
0c90 : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c94 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c95 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
0c97 : 48                       pha
0c98 : a2ff                     ldx #$ff        ;ff
0c9a : 8a                       txa
0c9b : 28                       plp             
0c9c : a8                       tay
                                tst_y $ff,$ff-zero
0c9d : 08              >            php         ;save flags
0c9e : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ca0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca2 : 68              >            pla         ;load status
0ca3 : 48              >            pha
                       >            cmp_flag $ff-zero
0ca4 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ca6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca8 : 28              >            plp         ;restore status
                        
0ca9 : 08                       php
0caa : e8                       inx             ;00
0cab : 8a                       txa
0cac : 28                       plp
0cad : a8                       tay
                                tst_y 0,$ff-minus
0cae : 08              >            php         ;save flags
0caf : c000            >            cpy #0     ;test result
                       >            trap_ne
0cb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb3 : 68              >            pla         ;load status
0cb4 : 48              >            pha
                       >            cmp_flag $ff-minus
0cb5 : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb9 : 28              >            plp         ;restore status
                        
0cba : 08                       php
0cbb : e8                       inx             ;01
0cbc : 8a                       txa
0cbd : 28                       plp
0cbe : a8                       tay
                                tst_y 1,$ff-minus-zero
0cbf : 08              >            php         ;save flags
0cc0 : c001            >            cpy #1     ;test result
                       >            trap_ne
0cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc4 : 68              >            pla         ;load status
0cc5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cc6 : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cca : 28              >            plp         ;restore status
                        
                                load_flag 0
0ccb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                        
0ccd : 48                       pha
0cce : a900                     lda #0
0cd0 : 8a                       txa
0cd1 : 28                       plp
0cd2 : a8                       tay
                                tst_y 1,0
0cd3 : 08              >            php         ;save flags
0cd4 : c001            >            cpy #1     ;test result
                       >            trap_ne
0cd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd8 : 68              >            pla         ;load status
0cd9 : 48              >            pha
                       >            cmp_flag 0
0cda : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cde : 28              >            plp         ;restore status
                        
0cdf : 08                       php
0ce0 : ca                       dex             ;00
0ce1 : 8a                       txa
0ce2 : 28                       plp
0ce3 : a8                       tay
                                tst_y 0,zero
0ce4 : 08              >            php         ;save flags
0ce5 : c000            >            cpy #0     ;test result
                       >            trap_ne
0ce7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce9 : 68              >            pla         ;load status
0cea : 48              >            pha
                       >            cmp_flag zero
0ceb : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ced : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cef : 28              >            plp         ;restore status
                        
0cf0 : 08                       php
0cf1 : ca                       dex             ;ff
0cf2 : 8a                       txa
0cf3 : 28                       plp
0cf4 : a8                       tay
                                tst_y $ff,minus
0cf5 : 08              >            php         ;save flags
0cf6 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0cf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfa : 68              >            pla         ;load status
0cfb : 48              >            pha
                       >            cmp_flag minus
0cfc : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d00 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0d01 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
0d03 : 48                       pha
0d04 : a0ff                     ldy #$ff        ;ff
0d06 : 98                       tya
0d07 : 28                       plp
0d08 : aa                       tax
                                tst_x $ff,$ff-zero
0d09 : 08              >            php         ;save flags
0d0a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0e : 68              >            pla         ;load status
0d0f : 48              >            pha
                       >            cmp_flag $ff-zero
0d10 : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d14 : 28              >            plp         ;restore status
                        
0d15 : 08                       php
0d16 : c8                       iny             ;00
0d17 : 98                       tya
0d18 : 28                       plp
0d19 : aa                       tax
                                tst_x 0,$ff-minus
0d1a : 08              >            php         ;save flags
0d1b : e000            >            cpx #0     ;test result
                       >            trap_ne
0d1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1f : 68              >            pla         ;load status
0d20 : 48              >            pha
                       >            cmp_flag $ff-minus
0d21 : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d25 : 28              >            plp         ;restore status
                        
0d26 : 08                       php
0d27 : c8                       iny             ;01
0d28 : 98                       tya
0d29 : 28                       plp
0d2a : aa                       tax
                                tst_x 1,$ff-minus-zero
0d2b : 08              >            php         ;save flags
0d2c : e001            >            cpx #1     ;test result
                       >            trap_ne
0d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d30 : 68              >            pla         ;load status
0d31 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d32 : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d36 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d37 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                        
0d39 : 48                       pha
0d3a : a900                     lda #0          ;preset status
0d3c : 98                       tya
0d3d : 28                       plp
0d3e : aa                       tax
                                tst_x 1,0
0d3f : 08              >            php         ;save flags
0d40 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d44 : 68              >            pla         ;load status
0d45 : 48              >            pha
                       >            cmp_flag 0
0d46 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d4a : 28              >            plp         ;restore status
                        
0d4b : 08                       php
0d4c : 88                       dey             ;00
0d4d : 98                       tya
0d4e : 28                       plp
0d4f : aa                       tax
                                tst_x 0,zero
0d50 : 08              >            php         ;save flags
0d51 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d55 : 68              >            pla         ;load status
0d56 : 48              >            pha
                       >            cmp_flag zero
0d57 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d5b : 28              >            plp         ;restore status
                        
0d5c : 08                       php
0d5d : 88                       dey             ;ff
0d5e : 98                       tya
0d5f : 28                       plp
0d60 : aa                       tax
                                tst_x $ff,minus
0d61 : 08              >            php         ;save flags
0d62 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d66 : 68              >            pla         ;load status
0d67 : 48              >            pha
                       >            cmp_flag minus
0d68 : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d6c : 28              >            plp         ;restore status
                        
                                next_test
0d6d : ad0002          >            lda test_case   ;previous test
0d70 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d74 : a90e            >            lda #test_num   ;*** next tests' number
0d76 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0d79 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d7b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0d7d : 48              >            pha         ;use stack to load status
0d7e : 28              >            plp
                        
0d7f : 9a                       txs
0d80 : 08                       php
0d81 : ad0101                   lda $101
                                cmp_flag $ff
0d84 : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0d86 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d88 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0d8a : 48              >            pha         ;use stack to load status
0d8b : 28              >            plp
                        
0d8c : 9a                       txs
0d8d : 08                       php
0d8e : ad0101                   lda $101
                                cmp_flag 0
0d91 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0d93 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d95 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d96 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0d98 : 48              >            pha         ;use stack to load status
0d99 : 28              >            plp
                        
0d9a : 9a                       txs
0d9b : 08                       php
0d9c : ad0001                   lda $100
                                cmp_flag $ff
0d9f : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0da1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0da3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0da5 : 48              >            pha         ;use stack to load status
0da6 : 28              >            plp
                        
0da7 : 9a                       txs
0da8 : 08                       php
0da9 : ad0001                   lda $100
                                cmp_flag 0
0dac : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0dae : d0fe            >        bne *           ;failed not equal (non zero)
                        
0db0 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0db1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0db3 : 48              >            pha         ;use stack to load status
0db4 : 28              >            plp
                        
0db5 : 9a                       txs
0db6 : 08                       php
0db7 : adff01                   lda $1ff
                                cmp_flag $ff
0dba : c9fb            >            cmp #($ff|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0dbc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dbe : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0dc0 : 48              >            pha         ;use stack to load status
0dc1 : 28              >            plp
                        
0dc2 : 9a                       txs
0dc3 : 08                       php
0dc4 : adff01                   lda $1ff
                                cmp_flag 0
0dc7 : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                
0dc9 : a201                     ldx #1
0dcb : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0dcc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0dce : 48              >            pha         ;use stack to load status
0dcf : 28              >            plp
                        
0dd0 : ba                       tsx             ;clears Z, N
0dd1 : 08                       php             ;sp=00
0dd2 : e001                     cpx #1
                                trap_ne
0dd4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd6 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0dd9 : c979            >            cmp #($ff-minus-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0ddb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0ddd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0ddf : 48              >            pha         ;use stack to load status
0de0 : 28              >            plp
                        
0de1 : ba                       tsx             ;clears N, sets Z
0de2 : 08                       php             ;sp=ff
0de3 : e000                     cpx #0
                                trap_ne
0de5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de7 : ad0001                   lda $100
                                cmp_flag $ff-minus
0dea : c97b            >            cmp #($ff-minus|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0dec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0dee : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0df0 : 48              >            pha         ;use stack to load status
0df1 : 28              >            plp
                        
0df2 : ba                       tsx             ;clears N, sets Z
0df3 : 08                       php             ;sp=fe
0df4 : e0ff                     cpx #$ff
                                trap_ne
0df6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df8 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0dfb : c9f9            >            cmp #($ff-zero|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0dfd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0dff : a201                     ldx #1
0e01 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0e02 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e04 : 48              >            pha         ;use stack to load status
0e05 : 28              >            plp
                        
0e06 : ba                       tsx             ;clears Z, N
0e07 : 08                       php             ;sp=00
0e08 : e001                     cpx #1
                                trap_ne
0e0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e0c : ad0101                   lda $101
                                cmp_flag 0
0e0f : c930            >            cmp #(0|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e13 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e15 : 48              >            pha         ;use stack to load status
0e16 : 28              >            plp
                        
0e17 : ba                       tsx             ;clears N, sets Z
0e18 : 08                       php             ;sp=ff
0e19 : e000                     cpx #0
                                trap_ne
0e1b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e1d : ad0001                   lda $100
                                cmp_flag zero
0e20 : c932            >            cmp #(zero|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e22 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e24 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e26 : 48              >            pha         ;use stack to load status
0e27 : 28              >            plp
                        
0e28 : ba                       tsx             ;clears N, sets Z
0e29 : 08                       php             ;sp=fe
0e2a : e0ff                     cpx #$ff
                                trap_ne
0e2c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e2e : adff01                   lda $1ff
                                cmp_flag minus
0e31 : c9b0            >            cmp #(minus|fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e33 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e35 : 68                       pla             ;sp=ff
                                next_test
0e36 : ad0002          >            lda test_case   ;previous test
0e39 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e3d : a90f            >            lda #test_num   ;*** next tests' number
0e3f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e42 : a003                     ldy #3
0e44 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e44 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e46 : 48              >            pha         ;use stack to load status
0e47 : 28              >            plp
                        
0e48 : b615                     ldx zp1,y
0e4a : 08                       php         ;test stores do not alter flags
0e4b : 8a                       txa
0e4c : 49c3                     eor #$c3
0e4e : 28                       plp
0e4f : 990302                   sta abst,y
0e52 : 08                       php         ;flags after load/store sequence
0e53 : 49c3                     eor #$c3
0e55 : d91802                   cmp abs1,y  ;test result
                                trap_ne
0e58 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e5a : 68                       pla         ;load status
                                eor_flag 0
0e5b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0e5d : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e60 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e62 : 88                       dey
0e63 : 10df                     bpl tldx                  
                        
0e65 : a003                     ldy #3
0e67 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e67 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e69 : 48              >            pha         ;use stack to load status
0e6a : 28              >            plp
                        
0e6b : b615                     ldx zp1,y
0e6d : 08                       php         ;test stores do not alter flags
0e6e : 8a                       txa
0e6f : 49c3                     eor #$c3
0e71 : 28                       plp
0e72 : 990302                   sta abst,y
0e75 : 08                       php         ;flags after load/store sequence
0e76 : 49c3                     eor #$c3
0e78 : d91802                   cmp abs1,y  ;test result
                                trap_ne
0e7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e7d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e7e : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0e80 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0e83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e85 : 88                       dey
0e86 : 10df                     bpl tldx1                  
                        
0e88 : a003                     ldy #3
0e8a :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e8a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e8c : 48              >            pha         ;use stack to load status
0e8d : 28              >            plp
                        
0e8e : be1802                   ldx abs1,y
0e91 : 08                       php         ;test stores do not alter flags
0e92 : 8a                       txa
0e93 : 49c3                     eor #$c3
0e95 : aa                       tax
0e96 : 28                       plp
0e97 : 960c                     stx zpt,y
0e99 : 08                       php         ;flags after load/store sequence
0e9a : 49c3                     eor #$c3
0e9c : d91500                   cmp zp1,y   ;test result
                                trap_ne
0e9f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea1 : 68                       pla         ;load status
                                eor_flag 0
0ea2 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0ea4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0ea7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea9 : 88                       dey
0eaa : 10de                     bpl tldx2                  
                        
0eac : a003                     ldy #3
0eae :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0eae : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0eb0 : 48              >            pha         ;use stack to load status
0eb1 : 28              >            plp
                        
0eb2 : be1802                   ldx abs1,y
0eb5 : 08                       php         ;test stores do not alter flags
0eb6 : 8a                       txa
0eb7 : 49c3                     eor #$c3
0eb9 : aa                       tax
0eba : 28                       plp
0ebb : 960c                     stx zpt,y
0ebd : 08                       php         ;flags after load/store sequence
0ebe : 49c3                     eor #$c3
0ec0 : d91500                   cmp zp1,y   ;test result
                                trap_ne
0ec3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ec6 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0ec8 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0ecb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ecd : 88                       dey
0ece : 10de                     bpl tldx3
                                
0ed0 : a003                     ldy #3      ;testing store result
0ed2 : a200                     ldx #0
0ed4 : b90c00           tstx    lda zpt,y
0ed7 : 49c3                     eor #$c3
0ed9 : d91500                   cmp zp1,y
                                trap_ne     ;store to zp data
0edc : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ede : 960c                     stx zpt,y   ;clear                
0ee0 : b90302                   lda abst,y
0ee3 : 49c3                     eor #$c3
0ee5 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0ee8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eea : 8a                       txa
0eeb : 990302                   sta abst,y  ;clear                
0eee : 88                       dey
0eef : 10e3                     bpl tstx
                                next_test
0ef1 : ad0002          >            lda test_case   ;previous test
0ef4 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ef6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0ef8 : a910            >            lda #test_num   ;*** next tests' number
0efa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0efd : a0fd                     ldy #3+$fa
0eff : b61b             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0f01 : 8a                       txa
0f02 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0f05 : 88                       dey
0f06 : c0fa                     cpy #$fa
0f08 : b0f5                     bcs tldx4                  
0f0a : a0fd                     ldy #3+$fa
0f0c : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0f0f : 9612                     stx zpt-$fa&$ff,y
0f11 : 88                       dey
0f12 : c0fa                     cpy #$fa
0f14 : b0f6                     bcs tldx5                  
0f16 : a003                     ldy #3      ;testing wraparound result
0f18 : a200                     ldx #0
0f1a : b90c00           tstx1   lda zpt,y
0f1d : d91500                   cmp zp1,y
                                trap_ne     ;store to zp data
0f20 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f22 : 960c                     stx zpt,y   ;clear                
0f24 : b90302                   lda abst,y
0f27 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0f2a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f2c : 8a                       txa
0f2d : 990302                   sta abst,y  ;clear                
0f30 : 88                       dey
0f31 : 10e7                     bpl tstx1
                                next_test
0f33 : ad0002          >            lda test_case   ;previous test
0f36 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0f3a : a911            >            lda #test_num   ;*** next tests' number
0f3c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f3f : a203                     ldx #3
0f41 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f41 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0f43 : 48              >            pha         ;use stack to load status
0f44 : 28              >            plp
                        
0f45 : b415                     ldy zp1,x
0f47 : 08                       php         ;test stores do not alter flags
0f48 : 98                       tya
0f49 : 49c3                     eor #$c3
0f4b : 28                       plp
0f4c : 9d0302                   sta abst,x
0f4f : 08                       php         ;flags after load/store sequence
0f50 : 49c3                     eor #$c3
0f52 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0f55 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f57 : 68                       pla         ;load status
                                eor_flag 0
0f58 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0f5a : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f5d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f5f : ca                       dex
0f60 : 10df                     bpl tldy                  
                        
0f62 : a203                     ldx #3
0f64 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f64 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0f66 : 48              >            pha         ;use stack to load status
0f67 : 28              >            plp
                        
0f68 : b415                     ldy zp1,x
0f6a : 08                       php         ;test stores do not alter flags
0f6b : 98                       tya
0f6c : 49c3                     eor #$c3
0f6e : 28                       plp
0f6f : 9d0302                   sta abst,x
0f72 : 08                       php         ;flags after load/store sequence
0f73 : 49c3                     eor #$c3
0f75 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
0f78 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f7a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f7b : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0f7d : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0f80 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f82 : ca                       dex
0f83 : 10df                     bpl tldy1                  
                        
0f85 : a203                     ldx #3
0f87 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f87 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0f89 : 48              >            pha         ;use stack to load status
0f8a : 28              >            plp
                        
0f8b : bc1802                   ldy abs1,x
0f8e : 08                       php         ;test stores do not alter flags
0f8f : 98                       tya
0f90 : 49c3                     eor #$c3
0f92 : a8                       tay
0f93 : 28                       plp
0f94 : 940c                     sty zpt,x
0f96 : 08                       php         ;flags after load/store sequence
0f97 : 49c3                     eor #$c3
0f99 : d515                     cmp zp1,x   ;test result
                                trap_ne
0f9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f9d : 68                       pla         ;load status
                                eor_flag 0
0f9e : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0fa0 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0fa3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa5 : ca                       dex
0fa6 : 10df                     bpl tldy2                  
                        
0fa8 : a203                     ldx #3
0faa :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0faa : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0fac : 48              >            pha         ;use stack to load status
0fad : 28              >            plp
                        
0fae : bc1802                   ldy abs1,x
0fb1 : 08                       php         ;test stores do not alter flags
0fb2 : 98                       tya
0fb3 : 49c3                     eor #$c3
0fb5 : a8                       tay
0fb6 : 28                       plp
0fb7 : 940c                     sty zpt,x
0fb9 : 08                       php         ;flags after load/store sequence
0fba : 49c3                     eor #$c3
0fbc : d515                     cmp zp1,x   ;test result
                                trap_ne
0fbe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fc1 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
0fc3 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
0fc6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc8 : ca                       dex
0fc9 : 10df                     bpl tldy3
                        
0fcb : a203                     ldx #3      ;testing store result
0fcd : a000                     ldy #0
0fcf : b50c             tsty    lda zpt,x
0fd1 : 49c3                     eor #$c3
0fd3 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fd5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fd7 : 940c                     sty zpt,x   ;clear                
0fd9 : bd0302                   lda abst,x
0fdc : 49c3                     eor #$c3
0fde : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fe1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe3 : 8a                       txa
0fe4 : 9d0302                   sta abst,x  ;clear                
0fe7 : ca                       dex
0fe8 : 10e5                     bpl tsty
                                next_test
0fea : ad0002          >            lda test_case   ;previous test
0fed : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0ff1 : a912            >            lda #test_num   ;*** next tests' number
0ff3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0ff6 : a2fd                     ldx #3+$fa
0ff8 : b41b             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0ffa : 98                       tya
0ffb : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0ffe : ca                       dex
0fff : e0fa                     cpx #$fa
1001 : b0f5                     bcs tldy4                  
1003 : a2fd                     ldx #3+$fa
1005 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
1008 : 9412                     sty zpt-$fa&$ff,x
100a : ca                       dex
100b : e0fa                     cpx #$fa
100d : b0f6                     bcs tldy5                  
100f : a203                     ldx #3      ;testing wraparound result
1011 : a000                     ldy #0
1013 : b50c             tsty1   lda zpt,x
1015 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1017 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1019 : 940c                     sty zpt,x   ;clear                
101b : bd0302                   lda abst,x
101e : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1021 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1023 : 8a                       txa
1024 : 9d0302                   sta abst,x  ;clear                
1027 : ca                       dex
1028 : 10e9                     bpl tsty1
                                next_test
102a : ad0002          >            lda test_case   ;previous test
102d : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
102f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
1031 : a913            >            lda #test_num   ;*** next tests' number
1033 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1036 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1038 : 48              >            pha         ;use stack to load status
1039 : 28              >            plp
                        
103a : a615                     ldx zp1
103c : 08                       php         ;test stores do not alter flags
103d : 8a                       txa
103e : 49c3                     eor #$c3
1040 : aa                       tax
1041 : 28                       plp
1042 : 8e0302                   stx abst
1045 : 08                       php         ;flags after load/store sequence
1046 : 49c3                     eor #$c3
1048 : aa                       tax
1049 : e0c3                     cpx #$c3    ;test result
                                trap_ne
104b : d0fe            >        bne *           ;failed not equal (non zero)
                        
104d : 68                       pla         ;load status
                                eor_flag 0
104e : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1050 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1053 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1055 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1057 : 48              >            pha         ;use stack to load status
1058 : 28              >            plp
                        
1059 : a616                     ldx zp1+1
105b : 08                       php         ;test stores do not alter flags
105c : 8a                       txa
105d : 49c3                     eor #$c3
105f : aa                       tax
1060 : 28                       plp
1061 : 8e0402                   stx abst+1
1064 : 08                       php         ;flags after load/store sequence
1065 : 49c3                     eor #$c3
1067 : aa                       tax
1068 : e082                     cpx #$82    ;test result
                                trap_ne
106a : d0fe            >        bne *           ;failed not equal (non zero)
                        
106c : 68                       pla         ;load status
                                eor_flag 0
106d : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
106f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1072 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1074 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1076 : 48              >            pha         ;use stack to load status
1077 : 28              >            plp
                        
1078 : a617                     ldx zp1+2
107a : 08                       php         ;test stores do not alter flags
107b : 8a                       txa
107c : 49c3                     eor #$c3
107e : aa                       tax
107f : 28                       plp
1080 : 8e0502                   stx abst+2
1083 : 08                       php         ;flags after load/store sequence
1084 : 49c3                     eor #$c3
1086 : aa                       tax
1087 : e041                     cpx #$41    ;test result
                                trap_ne
1089 : d0fe            >        bne *           ;failed not equal (non zero)
                        
108b : 68                       pla         ;load status
                                eor_flag 0
108c : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
108e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1091 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1093 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1095 : 48              >            pha         ;use stack to load status
1096 : 28              >            plp
                        
1097 : a618                     ldx zp1+3
1099 : 08                       php         ;test stores do not alter flags
109a : 8a                       txa
109b : 49c3                     eor #$c3
109d : aa                       tax
109e : 28                       plp
109f : 8e0602                   stx abst+3
10a2 : 08                       php         ;flags after load/store sequence
10a3 : 49c3                     eor #$c3
10a5 : aa                       tax
10a6 : e000                     cpx #0      ;test result
                                trap_ne
10a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10aa : 68                       pla         ;load status
                                eor_flag 0
10ab : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
10ad : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
10b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
10b2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
10b4 : 48              >            pha         ;use stack to load status
10b5 : 28              >            plp
                        
10b6 : a615                     ldx zp1  
10b8 : 08                       php         ;test stores do not alter flags
10b9 : 8a                       txa
10ba : 49c3                     eor #$c3
10bc : aa                       tax
10bd : 28                       plp
10be : 8e0302                   stx abst  
10c1 : 08                       php         ;flags after load/store sequence
10c2 : 49c3                     eor #$c3
10c4 : aa                       tax
10c5 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
10c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10c9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10ca : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
10cc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
10cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10d1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
10d3 : 48              >            pha         ;use stack to load status
10d4 : 28              >            plp
                        
10d5 : a616                     ldx zp1+1
10d7 : 08                       php         ;test stores do not alter flags
10d8 : 8a                       txa
10d9 : 49c3                     eor #$c3
10db : aa                       tax
10dc : 28                       plp
10dd : 8e0402                   stx abst+1
10e0 : 08                       php         ;flags after load/store sequence
10e1 : 49c3                     eor #$c3
10e3 : aa                       tax
10e4 : e082                     cpx #$82    ;test result
                                trap_ne
10e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10e8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10e9 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
10eb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
10ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10f0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
10f2 : 48              >            pha         ;use stack to load status
10f3 : 28              >            plp
                        
10f4 : a617                     ldx zp1+2
10f6 : 08                       php         ;test stores do not alter flags
10f7 : 8a                       txa
10f8 : 49c3                     eor #$c3
10fa : aa                       tax
10fb : 28                       plp
10fc : 8e0502                   stx abst+2
10ff : 08                       php         ;flags after load/store sequence
1100 : 49c3                     eor #$c3
1102 : aa                       tax
1103 : e041                     cpx #$41    ;test result
                                trap_ne     ;
1105 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1107 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1108 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
110a : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
110d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
110f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1111 : 48              >            pha         ;use stack to load status
1112 : 28              >            plp
                        
1113 : a618                     ldx zp1+3
1115 : 08                       php         ;test stores do not alter flags
1116 : 8a                       txa
1117 : 49c3                     eor #$c3
1119 : aa                       tax
111a : 28                       plp
111b : 8e0602                   stx abst+3
111e : 08                       php         ;flags after load/store sequence
111f : 49c3                     eor #$c3
1121 : aa                       tax
1122 : e000                     cpx #0      ;test result
                                trap_ne
1124 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1126 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1127 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1129 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
112c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
112e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1130 : 48              >            pha         ;use stack to load status
1131 : 28              >            plp
                        
1132 : ae1802                   ldx abs1  
1135 : 08                       php         ;test stores do not alter flags
1136 : 8a                       txa
1137 : 49c3                     eor #$c3
1139 : aa                       tax
113a : 28                       plp
113b : 860c                     stx zpt  
113d : 08                       php         ;flags after load/store sequence
113e : 49c3                     eor #$c3
1140 : c515                     cmp zp1     ;test result
                                trap_ne
1142 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1144 : 68                       pla         ;load status
                                eor_flag 0
1145 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1147 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
114a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
114c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
114e : 48              >            pha         ;use stack to load status
114f : 28              >            plp
                        
1150 : ae1902                   ldx abs1+1
1153 : 08                       php         ;test stores do not alter flags
1154 : 8a                       txa
1155 : 49c3                     eor #$c3
1157 : aa                       tax
1158 : 28                       plp
1159 : 860d                     stx zpt+1
115b : 08                       php         ;flags after load/store sequence
115c : 49c3                     eor #$c3
115e : c516                     cmp zp1+1   ;test result
                                trap_ne
1160 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1162 : 68                       pla         ;load status
                                eor_flag 0
1163 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1165 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1168 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
116a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
116c : 48              >            pha         ;use stack to load status
116d : 28              >            plp
                        
116e : ae1a02                   ldx abs1+2
1171 : 08                       php         ;test stores do not alter flags
1172 : 8a                       txa
1173 : 49c3                     eor #$c3
1175 : aa                       tax
1176 : 28                       plp
1177 : 860e                     stx zpt+2
1179 : 08                       php         ;flags after load/store sequence
117a : 49c3                     eor #$c3
117c : c517                     cmp zp1+2   ;test result
                                trap_ne
117e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1180 : 68                       pla         ;load status
                                eor_flag 0
1181 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1183 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1186 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1188 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
118a : 48              >            pha         ;use stack to load status
118b : 28              >            plp
                        
118c : ae1b02                   ldx abs1+3
118f : 08                       php         ;test stores do not alter flags
1190 : 8a                       txa
1191 : 49c3                     eor #$c3
1193 : aa                       tax
1194 : 28                       plp
1195 : 860f                     stx zpt+3
1197 : 08                       php         ;flags after load/store sequence
1198 : 49c3                     eor #$c3
119a : c518                     cmp zp1+3   ;test result
                                trap_ne
119c : d0fe            >        bne *           ;failed not equal (non zero)
                        
119e : 68                       pla         ;load status
                                eor_flag 0
119f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
11a1 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
11a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
11a6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
11a8 : 48              >            pha         ;use stack to load status
11a9 : 28              >            plp
                        
11aa : ae1802                   ldx abs1  
11ad : 08                       php         ;test stores do not alter flags
11ae : 8a                       txa
11af : 49c3                     eor #$c3
11b1 : aa                       tax
11b2 : 28                       plp
11b3 : 860c                     stx zpt  
11b5 : 08                       php         ;flags after load/store sequence
11b6 : 49c3                     eor #$c3
11b8 : aa                       tax
11b9 : e415                     cpx zp1     ;test result
                                trap_ne
11bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
11bd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11be : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
11c0 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
11c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11c5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
11c7 : 48              >            pha         ;use stack to load status
11c8 : 28              >            plp
                        
11c9 : ae1902                   ldx abs1+1
11cc : 08                       php         ;test stores do not alter flags
11cd : 8a                       txa
11ce : 49c3                     eor #$c3
11d0 : aa                       tax
11d1 : 28                       plp
11d2 : 860d                     stx zpt+1
11d4 : 08                       php         ;flags after load/store sequence
11d5 : 49c3                     eor #$c3
11d7 : aa                       tax
11d8 : e416                     cpx zp1+1   ;test result
                                trap_ne
11da : d0fe            >        bne *           ;failed not equal (non zero)
                        
11dc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11dd : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
11df : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
11e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11e4 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
11e6 : 48              >            pha         ;use stack to load status
11e7 : 28              >            plp
                        
11e8 : ae1a02                   ldx abs1+2
11eb : 08                       php         ;test stores do not alter flags
11ec : 8a                       txa
11ed : 49c3                     eor #$c3
11ef : aa                       tax
11f0 : 28                       plp
11f1 : 860e                     stx zpt+2
11f3 : 08                       php         ;flags after load/store sequence
11f4 : 49c3                     eor #$c3
11f6 : aa                       tax
11f7 : e417                     cpx zp1+2   ;test result
                                trap_ne
11f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11fb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11fc : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
11fe : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1201 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1203 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1205 : 48              >            pha         ;use stack to load status
1206 : 28              >            plp
                        
1207 : ae1b02                   ldx abs1+3
120a : 08                       php         ;test stores do not alter flags
120b : 8a                       txa
120c : 49c3                     eor #$c3
120e : aa                       tax
120f : 28                       plp
1210 : 860f                     stx zpt+3
1212 : 08                       php         ;flags after load/store sequence
1213 : 49c3                     eor #$c3
1215 : aa                       tax
1216 : e418                     cpx zp1+3   ;test result
                                trap_ne
1218 : d0fe            >        bne *           ;failed not equal (non zero)
                        
121a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
121b : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
121d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1220 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
1222 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1224 : 48              >            pha         ;use stack to load status
1225 : 28              >            plp
                        
1226 : a2c3                     ldx #$c3
1228 : 08                       php
1229 : ec1802                   cpx abs1    ;test result
                                trap_ne
122c : d0fe            >        bne *           ;failed not equal (non zero)
                        
122e : 68                       pla         ;load status
                                eor_flag 0
122f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1231 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1234 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1236 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1238 : 48              >            pha         ;use stack to load status
1239 : 28              >            plp
                        
123a : a282                     ldx #$82
123c : 08                       php
123d : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1240 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1242 : 68                       pla         ;load status
                                eor_flag 0
1243 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1245 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1248 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
124a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
124c : 48              >            pha         ;use stack to load status
124d : 28              >            plp
                        
124e : a241                     ldx #$41
1250 : 08                       php
1251 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1254 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1256 : 68                       pla         ;load status
                                eor_flag 0
1257 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1259 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
125c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
125e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1260 : 48              >            pha         ;use stack to load status
1261 : 28              >            plp
                        
1262 : a200                     ldx #0
1264 : 08                       php
1265 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
1268 : d0fe            >        bne *           ;failed not equal (non zero)
                        
126a : 68                       pla         ;load status
                                eor_flag 0
126b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
126d : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1270 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1272 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1274 : 48              >            pha         ;use stack to load status
1275 : 28              >            plp
                        
1276 : a2c3                     ldx #$c3  
1278 : 08                       php
1279 : ec1802                   cpx abs1    ;test result
                                trap_ne
127c : d0fe            >        bne *           ;failed not equal (non zero)
                        
127e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
127f : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1281 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1284 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1286 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1288 : 48              >            pha         ;use stack to load status
1289 : 28              >            plp
                        
128a : a282                     ldx #$82
128c : 08                       php
128d : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1290 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1292 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1293 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1295 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1298 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
129a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
129c : 48              >            pha         ;use stack to load status
129d : 28              >            plp
                        
129e : a241                     ldx #$41
12a0 : 08                       php
12a1 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
12a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12a7 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
12a9 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
12ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12ae : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
12b0 : 48              >            pha         ;use stack to load status
12b1 : 28              >            plp
                        
12b2 : a200                     ldx #0
12b4 : 08                       php
12b5 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
12b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ba : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12bb : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
12bd : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
12c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
12c2 : a200                     ldx #0
12c4 : a50c                     lda zpt  
12c6 : 49c3                     eor #$c3
12c8 : c515                     cmp zp1  
                                trap_ne     ;store to zp data
12ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
12cc : 860c                     stx zpt     ;clear                
12ce : ad0302                   lda abst  
12d1 : 49c3                     eor #$c3
12d3 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
12d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d8 : 8e0302                   stx abst    ;clear                
12db : a50d                     lda zpt+1
12dd : 49c3                     eor #$c3
12df : c516                     cmp zp1+1
                                trap_ne     ;store to zp data
12e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e3 : 860d                     stx zpt+1   ;clear                
12e5 : ad0402                   lda abst+1
12e8 : 49c3                     eor #$c3
12ea : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
12ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ef : 8e0402                   stx abst+1  ;clear                
12f2 : a50e                     lda zpt+2
12f4 : 49c3                     eor #$c3
12f6 : c517                     cmp zp1+2
                                trap_ne     ;store to zp data
12f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fa : 860e                     stx zpt+2   ;clear                
12fc : ad0502                   lda abst+2
12ff : 49c3                     eor #$c3
1301 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1304 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1306 : 8e0502                   stx abst+2  ;clear                
1309 : a50f                     lda zpt+3
130b : 49c3                     eor #$c3
130d : c518                     cmp zp1+3
                                trap_ne     ;store to zp data
130f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1311 : 860f                     stx zpt+3   ;clear                
1313 : ad0602                   lda abst+3
1316 : 49c3                     eor #$c3
1318 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
131b : d0fe            >        bne *           ;failed not equal (non zero)
                        
131d : 8e0602                   stx abst+3  ;clear                
                                next_test
1320 : ad0002          >            lda test_case   ;previous test
1323 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1325 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1327 : a914            >            lda #test_num   ;*** next tests' number
1329 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
132c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
132e : 48              >            pha         ;use stack to load status
132f : 28              >            plp
                        
1330 : a415                     ldy zp1  
1332 : 08                       php         ;test stores do not alter flags
1333 : 98                       tya
1334 : 49c3                     eor #$c3
1336 : a8                       tay
1337 : 28                       plp
1338 : 8c0302                   sty abst  
133b : 08                       php         ;flags after load/store sequence
133c : 49c3                     eor #$c3
133e : a8                       tay
133f : c0c3                     cpy #$c3    ;test result
                                trap_ne
1341 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1343 : 68                       pla         ;load status
                                eor_flag 0
1344 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1346 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1349 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
134b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
134d : 48              >            pha         ;use stack to load status
134e : 28              >            plp
                        
134f : a416                     ldy zp1+1
1351 : 08                       php         ;test stores do not alter flags
1352 : 98                       tya
1353 : 49c3                     eor #$c3
1355 : a8                       tay
1356 : 28                       plp
1357 : 8c0402                   sty abst+1
135a : 08                       php         ;flags after load/store sequence
135b : 49c3                     eor #$c3
135d : a8                       tay
135e : c082                     cpy #$82    ;test result
                                trap_ne
1360 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1362 : 68                       pla         ;load status
                                eor_flag 0
1363 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1365 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1368 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
136a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
136c : 48              >            pha         ;use stack to load status
136d : 28              >            plp
                        
136e : a417                     ldy zp1+2
1370 : 08                       php         ;test stores do not alter flags
1371 : 98                       tya
1372 : 49c3                     eor #$c3
1374 : a8                       tay
1375 : 28                       plp
1376 : 8c0502                   sty abst+2
1379 : 08                       php         ;flags after load/store sequence
137a : 49c3                     eor #$c3
137c : a8                       tay
137d : c041                     cpy #$41    ;test result
                                trap_ne
137f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1381 : 68                       pla         ;load status
                                eor_flag 0
1382 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1384 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1387 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1389 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
138b : 48              >            pha         ;use stack to load status
138c : 28              >            plp
                        
138d : a418                     ldy zp1+3
138f : 08                       php         ;test stores do not alter flags
1390 : 98                       tya
1391 : 49c3                     eor #$c3
1393 : a8                       tay
1394 : 28                       plp
1395 : 8c0602                   sty abst+3
1398 : 08                       php         ;flags after load/store sequence
1399 : 49c3                     eor #$c3
139b : a8                       tay
139c : c000                     cpy #0      ;test result
                                trap_ne
139e : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a0 : 68                       pla         ;load status
                                eor_flag 0
13a1 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
13a3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
13a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
13a8 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
13aa : 48              >            pha         ;use stack to load status
13ab : 28              >            plp
                        
13ac : a415                     ldy zp1  
13ae : 08                       php         ;test stores do not alter flags
13af : 98                       tya
13b0 : 49c3                     eor #$c3
13b2 : a8                       tay
13b3 : 28                       plp
13b4 : 8c0302                   sty abst  
13b7 : 08                       php         ;flags after load/store sequence
13b8 : 49c3                     eor #$c3
13ba : a8                       tay
13bb : c0c3                     cpy #$c3    ;test result
                                trap_ne
13bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
13bf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13c0 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
13c2 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
13c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13c7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
13c9 : 48              >            pha         ;use stack to load status
13ca : 28              >            plp
                        
13cb : a416                     ldy zp1+1
13cd : 08                       php         ;test stores do not alter flags
13ce : 98                       tya
13cf : 49c3                     eor #$c3
13d1 : a8                       tay
13d2 : 28                       plp
13d3 : 8c0402                   sty abst+1
13d6 : 08                       php         ;flags after load/store sequence
13d7 : 49c3                     eor #$c3
13d9 : a8                       tay
13da : c082                     cpy #$82   ;test result
                                trap_ne
13dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
13de : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13df : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
13e1 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
13e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13e6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
13e8 : 48              >            pha         ;use stack to load status
13e9 : 28              >            plp
                        
13ea : a417                     ldy zp1+2
13ec : 08                       php         ;test stores do not alter flags
13ed : 98                       tya
13ee : 49c3                     eor #$c3
13f0 : a8                       tay
13f1 : 28                       plp
13f2 : 8c0502                   sty abst+2
13f5 : 08                       php         ;flags after load/store sequence
13f6 : 49c3                     eor #$c3
13f8 : a8                       tay
13f9 : c041                     cpy #$41    ;test result
                                trap_ne
13fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
13fd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13fe : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1400 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1403 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1405 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1407 : 48              >            pha         ;use stack to load status
1408 : 28              >            plp
                        
1409 : a418                     ldy zp1+3
140b : 08                       php         ;test stores do not alter flags
140c : 98                       tya
140d : 49c3                     eor #$c3
140f : a8                       tay
1410 : 28                       plp
1411 : 8c0602                   sty abst+3
1414 : 08                       php         ;flags after load/store sequence
1415 : 49c3                     eor #$c3
1417 : a8                       tay
1418 : c000                     cpy #0      ;test result
                                trap_ne
141a : d0fe            >        bne *           ;failed not equal (non zero)
                        
141c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
141d : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
141f : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1422 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1424 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1426 : 48              >            pha         ;use stack to load status
1427 : 28              >            plp
                        
1428 : ac1802                   ldy abs1  
142b : 08                       php         ;test stores do not alter flags
142c : 98                       tya
142d : 49c3                     eor #$c3
142f : a8                       tay
1430 : 28                       plp
1431 : 840c                     sty zpt  
1433 : 08                       php         ;flags after load/store sequence
1434 : 49c3                     eor #$c3
1436 : a8                       tay
1437 : c415                     cpy zp1     ;test result
                                trap_ne
1439 : d0fe            >        bne *           ;failed not equal (non zero)
                        
143b : 68                       pla         ;load status
                                eor_flag 0
143c : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
143e : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1441 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1443 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1445 : 48              >            pha         ;use stack to load status
1446 : 28              >            plp
                        
1447 : ac1902                   ldy abs1+1
144a : 08                       php         ;test stores do not alter flags
144b : 98                       tya
144c : 49c3                     eor #$c3
144e : a8                       tay
144f : 28                       plp
1450 : 840d                     sty zpt+1
1452 : 08                       php         ;flags after load/store sequence
1453 : 49c3                     eor #$c3
1455 : a8                       tay
1456 : c416                     cpy zp1+1   ;test result
                                trap_ne
1458 : d0fe            >        bne *           ;failed not equal (non zero)
                        
145a : 68                       pla         ;load status
                                eor_flag 0
145b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
145d : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1460 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1462 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1464 : 48              >            pha         ;use stack to load status
1465 : 28              >            plp
                        
1466 : ac1a02                   ldy abs1+2
1469 : 08                       php         ;test stores do not alter flags
146a : 98                       tya
146b : 49c3                     eor #$c3
146d : a8                       tay
146e : 28                       plp
146f : 840e                     sty zpt+2
1471 : 08                       php         ;flags after load/store sequence
1472 : 49c3                     eor #$c3
1474 : a8                       tay
1475 : c417                     cpy zp1+2   ;test result
                                trap_ne
1477 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1479 : 68                       pla         ;load status
                                eor_flag 0
147a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
147c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
147f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1481 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1483 : 48              >            pha         ;use stack to load status
1484 : 28              >            plp
                        
1485 : ac1b02                   ldy abs1+3
1488 : 08                       php         ;test stores do not alter flags
1489 : 98                       tya
148a : 49c3                     eor #$c3
148c : a8                       tay
148d : 28                       plp
148e : 840f                     sty zpt+3
1490 : 08                       php         ;flags after load/store sequence
1491 : 49c3                     eor #$c3
1493 : a8                       tay
1494 : c418                     cpy zp1+3   ;test result
                                trap_ne
1496 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1498 : 68                       pla         ;load status
                                eor_flag 0
1499 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
149b : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
149e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
14a0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14a2 : 48              >            pha         ;use stack to load status
14a3 : 28              >            plp
                        
14a4 : ac1802                   ldy abs1  
14a7 : 08                       php         ;test stores do not alter flags
14a8 : 98                       tya
14a9 : 49c3                     eor #$c3
14ab : a8                       tay
14ac : 28                       plp
14ad : 840c                     sty zpt  
14af : 08                       php         ;flags after load/store sequence
14b0 : 49c3                     eor #$c3
14b2 : a8                       tay
14b3 : c515                     cmp zp1     ;test result
                                trap_ne
14b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14b7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14b8 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
14ba : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
14bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14bf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14c1 : 48              >            pha         ;use stack to load status
14c2 : 28              >            plp
                        
14c3 : ac1902                   ldy abs1+1
14c6 : 08                       php         ;test stores do not alter flags
14c7 : 98                       tya
14c8 : 49c3                     eor #$c3
14ca : a8                       tay
14cb : 28                       plp
14cc : 840d                     sty zpt+1
14ce : 08                       php         ;flags after load/store sequence
14cf : 49c3                     eor #$c3
14d1 : a8                       tay
14d2 : c516                     cmp zp1+1   ;test result
                                trap_ne
14d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14d7 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
14d9 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
14dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14de : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14e0 : 48              >            pha         ;use stack to load status
14e1 : 28              >            plp
                        
14e2 : ac1a02                   ldy abs1+2
14e5 : 08                       php         ;test stores do not alter flags
14e6 : 98                       tya
14e7 : 49c3                     eor #$c3
14e9 : a8                       tay
14ea : 28                       plp
14eb : 840e                     sty zpt+2
14ed : 08                       php         ;flags after load/store sequence
14ee : 49c3                     eor #$c3
14f0 : a8                       tay
14f1 : c517                     cmp zp1+2   ;test result
                                trap_ne
14f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14f5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14f6 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
14f8 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
14fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14fd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14ff : 48              >            pha         ;use stack to load status
1500 : 28              >            plp
                        
1501 : ac1b02                   ldy abs1+3
1504 : 08                       php         ;test stores do not alter flags
1505 : 98                       tya
1506 : 49c3                     eor #$c3
1508 : a8                       tay
1509 : 28                       plp
150a : 840f                     sty zpt+3
150c : 08                       php         ;flags after load/store sequence
150d : 49c3                     eor #$c3
150f : a8                       tay
1510 : c518                     cmp zp1+3   ;test result
                                trap_ne
1512 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1514 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1515 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1517 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
151a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
151c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
151e : 48              >            pha         ;use stack to load status
151f : 28              >            plp
                        
1520 : a0c3                     ldy #$c3  
1522 : 08                       php
1523 : cc1802                   cpy abs1    ;test result
                                trap_ne
1526 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1528 : 68                       pla         ;load status
                                eor_flag 0
1529 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
152b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
152e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1530 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1532 : 48              >            pha         ;use stack to load status
1533 : 28              >            plp
                        
1534 : a082                     ldy #$82
1536 : 08                       php
1537 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
153a : d0fe            >        bne *           ;failed not equal (non zero)
                        
153c : 68                       pla         ;load status
                                eor_flag 0
153d : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
153f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1542 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1544 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1546 : 48              >            pha         ;use stack to load status
1547 : 28              >            plp
                        
1548 : a041                     ldy #$41
154a : 08                       php
154b : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
154e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1550 : 68                       pla         ;load status
                                eor_flag 0
1551 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1553 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1556 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1558 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
155a : 48              >            pha         ;use stack to load status
155b : 28              >            plp
                        
155c : a000                     ldy #0
155e : 08                       php
155f : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
1562 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1564 : 68                       pla         ;load status
                                eor_flag 0
1565 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1567 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
156a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
156c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
156e : 48              >            pha         ;use stack to load status
156f : 28              >            plp
                        
1570 : a0c3                     ldy #$c3  
1572 : 08                       php
1573 : cc1802                   cpy abs1    ;test result
                                trap_ne
1576 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1578 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1579 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
157b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
157e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1580 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1582 : 48              >            pha         ;use stack to load status
1583 : 28              >            plp
                        
1584 : a082                     ldy #$82
1586 : 08                       php
1587 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
158a : d0fe            >        bne *           ;failed not equal (non zero)
                        
158c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
158d : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
158f : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1592 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1594 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1596 : 48              >            pha         ;use stack to load status
1597 : 28              >            plp
                        
1598 : a041                     ldy #$41
159a : 08                       php
159b : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
159e : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15a1 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
15a3 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
15a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15a8 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
15aa : 48              >            pha         ;use stack to load status
15ab : 28              >            plp
                        
15ac : a000                     ldy #0
15ae : 08                       php
15af : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
15b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15b5 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
15b7 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
15ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
15bc : a000                     ldy #0
15be : a50c                     lda zpt  
15c0 : 49c3                     eor #$c3
15c2 : c515                     cmp zp1  
                                trap_ne     ;store to zp   data
15c4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15c6 : 840c                     sty zpt     ;clear                
15c8 : ad0302                   lda abst  
15cb : 49c3                     eor #$c3
15cd : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
15d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15d2 : 8c0302                   sty abst    ;clear                
15d5 : a50d                     lda zpt+1
15d7 : 49c3                     eor #$c3
15d9 : c516                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
15db : d0fe            >        bne *           ;failed not equal (non zero)
                        
15dd : 840d                     sty zpt+1   ;clear                
15df : ad0402                   lda abst+1
15e2 : 49c3                     eor #$c3
15e4 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
15e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e9 : 8c0402                   sty abst+1  ;clear                
15ec : a50e                     lda zpt+2
15ee : 49c3                     eor #$c3
15f0 : c517                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
15f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15f4 : 840e                     sty zpt+2   ;clear                
15f6 : ad0502                   lda abst+2
15f9 : 49c3                     eor #$c3
15fb : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
15fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1600 : 8c0502                   sty abst+2  ;clear                
1603 : a50f                     lda zpt+3
1605 : 49c3                     eor #$c3
1607 : c518                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
1609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
160b : 840f                     sty zpt+3   ;clear                
160d : ad0602                   lda abst+3
1610 : 49c3                     eor #$c3
1612 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1615 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1617 : 8c0602                   sty abst+3  ;clear                
                                next_test
161a : ad0002          >            lda test_case   ;previous test
161d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
161f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1621 : a915            >            lda #test_num   ;*** next tests' number
1623 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1626 : a203                     ldx #3
1628 :                  tldax    
                                set_stat 0
                       >            load_flag 0
1628 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
162a : 48              >            pha         ;use stack to load status
162b : 28              >            plp
                        
162c : b515                     lda zp1,x
162e : 08                       php         ;test stores do not alter flags
162f : 49c3                     eor #$c3
1631 : 28                       plp
1632 : 9d0302                   sta abst,x
1635 : 08                       php         ;flags after load/store sequence
1636 : 49c3                     eor #$c3
1638 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
163b : d0fe            >        bne *           ;failed not equal (non zero)
                        
163d : 68                       pla         ;load status
                                eor_flag 0
163e : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1640 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1643 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1645 : ca                       dex
1646 : 10e0                     bpl tldax                  
                        
1648 : a203                     ldx #3
164a :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
164a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
164c : 48              >            pha         ;use stack to load status
164d : 28              >            plp
                        
164e : b515                     lda zp1,x
1650 : 08                       php         ;test stores do not alter flags
1651 : 49c3                     eor #$c3
1653 : 28                       plp
1654 : 9d0302                   sta abst,x
1657 : 08                       php         ;flags after load/store sequence
1658 : 49c3                     eor #$c3
165a : dd1802                   cmp abs1,x   ;test result
                                trap_ne
165d : d0fe            >        bne *           ;failed not equal (non zero)
                        
165f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1660 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1662 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1665 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1667 : ca                       dex
1668 : 10e0                     bpl tldax1                  
                        
166a : a203                     ldx #3
166c :                  tldax2   
                                set_stat 0
                       >            load_flag 0
166c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
166e : 48              >            pha         ;use stack to load status
166f : 28              >            plp
                        
1670 : bd1802                   lda abs1,x
1673 : 08                       php         ;test stores do not alter flags
1674 : 49c3                     eor #$c3
1676 : 28                       plp
1677 : 950c                     sta zpt,x
1679 : 08                       php         ;flags after load/store sequence
167a : 49c3                     eor #$c3
167c : d515                     cmp zp1,x   ;test result
                                trap_ne
167e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1680 : 68                       pla         ;load status
                                eor_flag 0
1681 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1683 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1686 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1688 : ca                       dex
1689 : 10e1                     bpl tldax2                  
                        
168b : a203                     ldx #3
168d :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
168d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
168f : 48              >            pha         ;use stack to load status
1690 : 28              >            plp
                        
1691 : bd1802                   lda abs1,x
1694 : 08                       php         ;test stores do not alter flags
1695 : 49c3                     eor #$c3
1697 : 28                       plp
1698 : 950c                     sta zpt,x
169a : 08                       php         ;flags after load/store sequence
169b : 49c3                     eor #$c3
169d : d515                     cmp zp1,x   ;test result
                                trap_ne
169f : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16a2 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
16a4 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
16a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a9 : ca                       dex
16aa : 10e1                     bpl tldax3
                        
16ac : a203                     ldx #3      ;testing store result
16ae : a000                     ldy #0
16b0 : b50c             tstax   lda zpt,x
16b2 : 49c3                     eor #$c3
16b4 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b8 : 940c                     sty zpt,x   ;clear                
16ba : bd0302                   lda abst,x
16bd : 49c3                     eor #$c3
16bf : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
16c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16c4 : 8a                       txa
16c5 : 9d0302                   sta abst,x  ;clear                
16c8 : ca                       dex
16c9 : 10e5                     bpl tstax
                                next_test
16cb : ad0002          >            lda test_case   ;previous test
16ce : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
16d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
16d2 : a916            >            lda #test_num   ;*** next tests' number
16d4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
16d7 : a003                     ldy #3
16d9 :                  tlday    
                                set_stat 0
                       >            load_flag 0
16d9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
16db : 48              >            pha         ;use stack to load status
16dc : 28              >            plp
                        
16dd : b126                     lda (ind1),y
16df : 08                       php         ;test stores do not alter flags
16e0 : 49c3                     eor #$c3
16e2 : 28                       plp
16e3 : 990302                   sta abst,y
16e6 : 08                       php         ;flags after load/store sequence
16e7 : 49c3                     eor #$c3
16e9 : d91802                   cmp abs1,y  ;test result
                                trap_ne
16ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ee : 68                       pla         ;load status
                                eor_flag 0
16ef : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
16f1 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
16f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16f6 : 88                       dey
16f7 : 10e0                     bpl tlday                  
                        
16f9 : a003                     ldy #3
16fb :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
16fb : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
16fd : 48              >            pha         ;use stack to load status
16fe : 28              >            plp
                        
16ff : b126                     lda (ind1),y
1701 : 08                       php         ;test stores do not alter flags
1702 : 49c3                     eor #$c3
1704 : 28                       plp
1705 : 990302                   sta abst,y
1708 : 08                       php         ;flags after load/store sequence
1709 : 49c3                     eor #$c3
170b : d91802                   cmp abs1,y  ;test result
                                trap_ne
170e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1710 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1711 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1713 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1716 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1718 : 88                       dey
1719 : 10e0                     bpl tlday1                  
                        
171b : a003                     ldy #3      ;testing store result
171d : a200                     ldx #0
171f : b90302           tstay   lda abst,y
1722 : 49c3                     eor #$c3
1724 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1727 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1729 : 8a                       txa
172a : 990302                   sta abst,y  ;clear                
172d : 88                       dey
172e : 10ef                     bpl tstay
                        
1730 : a003                     ldy #3
1732 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
1732 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1734 : 48              >            pha         ;use stack to load status
1735 : 28              >            plp
                        
1736 : b91802                   lda abs1,y
1739 : 08                       php         ;test stores do not alter flags
173a : 49c3                     eor #$c3
173c : 28                       plp
173d : 9132                     sta (indt),y
173f : 08                       php         ;flags after load/store sequence
1740 : 49c3                     eor #$c3
1742 : d126                     cmp (ind1),y    ;test result
                                trap_ne
1744 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1746 : 68                       pla         ;load status
                                eor_flag 0
1747 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1749 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
174c : d0fe            >        bne *           ;failed not equal (non zero)
                        
174e : 88                       dey
174f : 10e1                     bpl tlday2                  
                        
1751 : a003                     ldy #3
1753 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1753 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1755 : 48              >            pha         ;use stack to load status
1756 : 28              >            plp
                        
1757 : b91802                   lda abs1,y
175a : 08                       php         ;test stores do not alter flags
175b : 49c3                     eor #$c3
175d : 28                       plp
175e : 9132                     sta (indt),y
1760 : 08                       php         ;flags after load/store sequence
1761 : 49c3                     eor #$c3
1763 : d126                     cmp (ind1),y   ;test result
                                trap_ne
1765 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1767 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1768 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
176a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
176d : d0fe            >        bne *           ;failed not equal (non zero)
                        
176f : 88                       dey
1770 : 10e1                     bpl tlday3
                                
1772 : a003                     ldy #3      ;testing store result
1774 : a200                     ldx #0
1776 : b90302           tstay1  lda abst,y
1779 : 49c3                     eor #$c3
177b : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
177e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1780 : 8a                       txa
1781 : 990302                   sta abst,y  ;clear                
1784 : 88                       dey
1785 : 10ef                     bpl tstay1
                                
1787 : a206                     ldx #6
1789 : a003                     ldy #3
178b :                  tldax4   
                                set_stat 0
                       >            load_flag 0
178b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
178d : 48              >            pha         ;use stack to load status
178e : 28              >            plp
                        
178f : a126                     lda (ind1,x)
1791 : 08                       php         ;test stores do not alter flags
1792 : 49c3                     eor #$c3
1794 : 28                       plp
1795 : 8132                     sta (indt,x)
1797 : 08                       php         ;flags after load/store sequence
1798 : 49c3                     eor #$c3
179a : d91802                   cmp abs1,y  ;test result
                                trap_ne
179d : d0fe            >        bne *           ;failed not equal (non zero)
                        
179f : 68                       pla         ;load status
                                eor_flag 0
17a0 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
17a2 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
17a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17a7 : ca                       dex
17a8 : ca                       dex
17a9 : 88                       dey
17aa : 10df                     bpl tldax4                  
                        
17ac : a206                     ldx #6
17ae : a003                     ldy #3
17b0 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
17b0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
17b2 : 48              >            pha         ;use stack to load status
17b3 : 28              >            plp
                        
17b4 : a126                     lda (ind1,x)
17b6 : 08                       php         ;test stores do not alter flags
17b7 : 49c3                     eor #$c3
17b9 : 28                       plp
17ba : 8132                     sta (indt,x)
17bc : 08                       php         ;flags after load/store sequence
17bd : 49c3                     eor #$c3
17bf : d91802                   cmp abs1,y  ;test result
                                trap_ne
17c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17c4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17c5 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
17c7 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
17ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
17cc : ca                       dex
17cd : ca                       dex
17ce : 88                       dey
17cf : 10df                     bpl tldax5
                        
17d1 : a003                     ldy #3      ;testing store result
17d3 : a200                     ldx #0
17d5 : b90302           tstay2  lda abst,y
17d8 : 49c3                     eor #$c3
17da : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
17dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
17df : 8a                       txa
17e0 : 990302                   sta abst,y  ;clear                
17e3 : 88                       dey
17e4 : 10ef                     bpl tstay2
                                next_test
17e6 : ad0002          >            lda test_case   ;previous test
17e9 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
17ed : a917            >            lda #test_num   ;*** next tests' number
17ef : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
17f2 : a2fd                     ldx #3+$fa
17f4 : b51b             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
17f6 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
17f9 : ca                       dex
17fa : e0fa                     cpx #$fa
17fc : b0f6                     bcs tldax6                  
17fe : a2fd                     ldx #3+$fa
1800 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
1803 : 9512                     sta zpt-$fa&$ff,x
1805 : ca                       dex
1806 : e0fa                     cpx #$fa
1808 : b0f6                     bcs tldax7
                                                  
180a : a203                     ldx #3      ;testing wraparound result
180c : a000                     ldy #0
180e : b50c             tstax1  lda zpt,x
1810 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1812 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1814 : 940c                     sty zpt,x   ;clear                
1816 : bd0302                   lda abst,x
1819 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
181c : d0fe            >        bne *           ;failed not equal (non zero)
                        
181e : 8a                       txa
181f : 9d0302                   sta abst,x  ;clear                
1822 : ca                       dex
1823 : 10e9                     bpl tstax1
                        
1825 : a0fb                     ldy #3+$f8
1827 : a2fe                     ldx #6+$f8
1829 : a12e             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
182b : 990b01                   sta abst-$f8,y
182e : ca                       dex
182f : ca                       dex
1830 : 88                       dey
1831 : c0f8                     cpy #$f8
1833 : b0f4                     bcs tlday4
1835 : a003                     ldy #3      ;testing wraparound result
1837 : a200                     ldx #0
1839 : b90302           tstay4  lda abst,y
183c : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
183f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1841 : 8a                       txa
1842 : 990302                   sta abst,y  ;clear                
1845 : 88                       dey
1846 : 10f1                     bpl tstay4
                                
1848 : a0fb                     ldy #3+$f8
184a : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
184d : 913a                     sta (inwt),y
184f : 88                       dey
1850 : c0f8                     cpy #$f8
1852 : b0f6                     bcs tlday5                  
1854 : a003                     ldy #3      ;testing wraparound result
1856 : a200                     ldx #0
1858 : b90302           tstay5  lda abst,y
185b : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
185e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1860 : 8a                       txa
1861 : 990302                   sta abst,y  ;clear                
1864 : 88                       dey
1865 : 10f1                     bpl tstay5
                        
1867 : a0fb                     ldy #3+$f8
1869 : a2fe                     ldx #6+$f8
186b : b130             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
186d : 813a                     sta (indt-$f8&$ff,x)
186f : ca                       dex
1870 : ca                       dex
1871 : 88                       dey
1872 : c0f8                     cpy #$f8
1874 : b0f5                     bcs tlday6
1876 : a003                     ldy #3      ;testing wraparound result
1878 : a200                     ldx #0
187a : b90302           tstay6  lda abst,y
187d : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1880 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1882 : 8a                       txa
1883 : 990302                   sta abst,y  ;clear                
1886 : 88                       dey
1887 : 10f1                     bpl tstay6
                                next_test
1889 : ad0002          >            lda test_case   ;previous test
188c : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
188e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
1890 : a918            >            lda #test_num   ;*** next tests' number
1892 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1895 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1897 : 48              >            pha         ;use stack to load status
1898 : 28              >            plp
                        
1899 : a515                     lda zp1
189b : 08                       php         ;test stores do not alter flags
189c : 49c3                     eor #$c3
189e : 28                       plp
189f : 8d0302                   sta abst
18a2 : 08                       php         ;flags after load/store sequence
18a3 : 49c3                     eor #$c3
18a5 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18a9 : 68                       pla         ;load status
                                eor_flag 0
18aa : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
18ac : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
18af : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18b1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
18b3 : 48              >            pha         ;use stack to load status
18b4 : 28              >            plp
                        
18b5 : a516                     lda zp1+1
18b7 : 08                       php         ;test stores do not alter flags
18b8 : 49c3                     eor #$c3
18ba : 28                       plp
18bb : 8d0402                   sta abst+1
18be : 08                       php         ;flags after load/store sequence
18bf : 49c3                     eor #$c3
18c1 : c982                     cmp #$82    ;test result
                                trap_ne
18c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18c5 : 68                       pla         ;load status
                                eor_flag 0
18c6 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
18c8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
18cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18cd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
18cf : 48              >            pha         ;use stack to load status
18d0 : 28              >            plp
                        
18d1 : a517                     lda zp1+2
18d3 : 08                       php         ;test stores do not alter flags
18d4 : 49c3                     eor #$c3
18d6 : 28                       plp
18d7 : 8d0502                   sta abst+2
18da : 08                       php         ;flags after load/store sequence
18db : 49c3                     eor #$c3
18dd : c941                     cmp #$41    ;test result
                                trap_ne
18df : d0fe            >        bne *           ;failed not equal (non zero)
                        
18e1 : 68                       pla         ;load status
                                eor_flag 0
18e2 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
18e4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
18e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18e9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
18eb : 48              >            pha         ;use stack to load status
18ec : 28              >            plp
                        
18ed : a518                     lda zp1+3
18ef : 08                       php         ;test stores do not alter flags
18f0 : 49c3                     eor #$c3
18f2 : 28                       plp
18f3 : 8d0602                   sta abst+3
18f6 : 08                       php         ;flags after load/store sequence
18f7 : 49c3                     eor #$c3
18f9 : c900                     cmp #0      ;test result
                                trap_ne
18fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
18fd : 68                       pla         ;load status
                                eor_flag 0
18fe : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1900 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1903 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1905 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1907 : 48              >            pha         ;use stack to load status
1908 : 28              >            plp
                        
1909 : a515                     lda zp1  
190b : 08                       php         ;test stores do not alter flags
190c : 49c3                     eor #$c3
190e : 28                       plp
190f : 8d0302                   sta abst  
1912 : 08                       php         ;flags after load/store sequence
1913 : 49c3                     eor #$c3
1915 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1917 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1919 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
191a : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
191c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
191f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1921 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1923 : 48              >            pha         ;use stack to load status
1924 : 28              >            plp
                        
1925 : a516                     lda zp1+1
1927 : 08                       php         ;test stores do not alter flags
1928 : 49c3                     eor #$c3
192a : 28                       plp
192b : 8d0402                   sta abst+1
192e : 08                       php         ;flags after load/store sequence
192f : 49c3                     eor #$c3
1931 : c982                     cmp #$82    ;test result
                                trap_ne
1933 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1935 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1936 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1938 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
193b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
193d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
193f : 48              >            pha         ;use stack to load status
1940 : 28              >            plp
                        
1941 : a517                     lda zp1+2
1943 : 08                       php         ;test stores do not alter flags
1944 : 49c3                     eor #$c3
1946 : 28                       plp
1947 : 8d0502                   sta abst+2
194a : 08                       php         ;flags after load/store sequence
194b : 49c3                     eor #$c3
194d : c941                     cmp #$41    ;test result
                                trap_ne
194f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1951 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1952 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1954 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1957 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1959 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
195b : 48              >            pha         ;use stack to load status
195c : 28              >            plp
                        
195d : a518                     lda zp1+3
195f : 08                       php         ;test stores do not alter flags
1960 : 49c3                     eor #$c3
1962 : 28                       plp
1963 : 8d0602                   sta abst+3
1966 : 08                       php         ;flags after load/store sequence
1967 : 49c3                     eor #$c3
1969 : c900                     cmp #0      ;test result
                                trap_ne
196b : d0fe            >        bne *           ;failed not equal (non zero)
                        
196d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
196e : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1970 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1975 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1977 : 48              >            pha         ;use stack to load status
1978 : 28              >            plp
                        
1979 : ad1802                   lda abs1  
197c : 08                       php         ;test stores do not alter flags
197d : 49c3                     eor #$c3
197f : 28                       plp
1980 : 850c                     sta zpt  
1982 : 08                       php         ;flags after load/store sequence
1983 : 49c3                     eor #$c3
1985 : c515                     cmp zp1     ;test result
                                trap_ne
1987 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1989 : 68                       pla         ;load status
                                eor_flag 0
198a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
198c : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
198f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1991 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1993 : 48              >            pha         ;use stack to load status
1994 : 28              >            plp
                        
1995 : ad1902                   lda abs1+1
1998 : 08                       php         ;test stores do not alter flags
1999 : 49c3                     eor #$c3
199b : 28                       plp
199c : 850d                     sta zpt+1
199e : 08                       php         ;flags after load/store sequence
199f : 49c3                     eor #$c3
19a1 : c516                     cmp zp1+1   ;test result
                                trap_ne
19a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19a5 : 68                       pla         ;load status
                                eor_flag 0
19a6 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
19a8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
19ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19ad : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
19af : 48              >            pha         ;use stack to load status
19b0 : 28              >            plp
                        
19b1 : ad1a02                   lda abs1+2
19b4 : 08                       php         ;test stores do not alter flags
19b5 : 49c3                     eor #$c3
19b7 : 28                       plp
19b8 : 850e                     sta zpt+2
19ba : 08                       php         ;flags after load/store sequence
19bb : 49c3                     eor #$c3
19bd : c517                     cmp zp1+2   ;test result
                                trap_ne
19bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
19c1 : 68                       pla         ;load status
                                eor_flag 0
19c2 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
19c4 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
19c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19c9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
19cb : 48              >            pha         ;use stack to load status
19cc : 28              >            plp
                        
19cd : ad1b02                   lda abs1+3
19d0 : 08                       php         ;test stores do not alter flags
19d1 : 49c3                     eor #$c3
19d3 : 28                       plp
19d4 : 850f                     sta zpt+3
19d6 : 08                       php         ;flags after load/store sequence
19d7 : 49c3                     eor #$c3
19d9 : c518                     cmp zp1+3   ;test result
                                trap_ne
19db : d0fe            >        bne *           ;failed not equal (non zero)
                        
19dd : 68                       pla         ;load status
                                eor_flag 0
19de : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
19e0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
19e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19e5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
19e7 : 48              >            pha         ;use stack to load status
19e8 : 28              >            plp
                        
19e9 : ad1802                   lda abs1  
19ec : 08                       php         ;test stores do not alter flags
19ed : 49c3                     eor #$c3
19ef : 28                       plp
19f0 : 850c                     sta zpt  
19f2 : 08                       php         ;flags after load/store sequence
19f3 : 49c3                     eor #$c3
19f5 : c515                     cmp zp1     ;test result
                                trap_ne
19f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19f9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19fa : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
19fc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
19ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a01 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a03 : 48              >            pha         ;use stack to load status
1a04 : 28              >            plp
                        
1a05 : ad1902                   lda abs1+1
1a08 : 08                       php         ;test stores do not alter flags
1a09 : 49c3                     eor #$c3
1a0b : 28                       plp
1a0c : 850d                     sta zpt+1
1a0e : 08                       php         ;flags after load/store sequence
1a0f : 49c3                     eor #$c3
1a11 : c516                     cmp zp1+1   ;test result
                                trap_ne
1a13 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a15 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a16 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a18 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a1b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a1d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a1f : 48              >            pha         ;use stack to load status
1a20 : 28              >            plp
                        
1a21 : ad1a02                   lda abs1+2
1a24 : 08                       php         ;test stores do not alter flags
1a25 : 49c3                     eor #$c3
1a27 : 28                       plp
1a28 : 850e                     sta zpt+2
1a2a : 08                       php         ;flags after load/store sequence
1a2b : 49c3                     eor #$c3
1a2d : c517                     cmp zp1+2   ;test result
                                trap_ne
1a2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a31 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a32 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a34 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a39 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a3b : 48              >            pha         ;use stack to load status
1a3c : 28              >            plp
                        
1a3d : ad1b02                   lda abs1+3
1a40 : 08                       php         ;test stores do not alter flags
1a41 : 49c3                     eor #$c3
1a43 : 28                       plp
1a44 : 850f                     sta zpt+3
1a46 : 08                       php         ;flags after load/store sequence
1a47 : 49c3                     eor #$c3
1a49 : c518                     cmp zp1+3   ;test result
                                trap_ne
1a4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a4e : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a50 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1a53 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a55 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1a57 : 48              >            pha         ;use stack to load status
1a58 : 28              >            plp
                        
1a59 : a9c3                     lda #$c3
1a5b : 08                       php
1a5c : cd1802                   cmp abs1    ;test result
                                trap_ne
1a5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a61 : 68                       pla         ;load status
                                eor_flag 0
1a62 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a64 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1a67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a69 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1a6b : 48              >            pha         ;use stack to load status
1a6c : 28              >            plp
                        
1a6d : a982                     lda #$82
1a6f : 08                       php
1a70 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1a73 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a75 : 68                       pla         ;load status
                                eor_flag 0
1a76 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a78 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a7d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1a7f : 48              >            pha         ;use stack to load status
1a80 : 28              >            plp
                        
1a81 : a941                     lda #$41
1a83 : 08                       php
1a84 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
1a87 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a89 : 68                       pla         ;load status
                                eor_flag 0
1a8a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1a8c : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a91 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1a93 : 48              >            pha         ;use stack to load status
1a94 : 28              >            plp
                        
1a95 : a900                     lda #0
1a97 : 08                       php
1a98 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
1a9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a9d : 68                       pla         ;load status
                                eor_flag 0
1a9e : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1aa0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1aa3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1aa5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1aa7 : 48              >            pha         ;use stack to load status
1aa8 : 28              >            plp
                        
1aa9 : a9c3                     lda #$c3  
1aab : 08                       php
1aac : cd1802                   cmp abs1    ;test result
                                trap_ne
1aaf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab2 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1ab4 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ab9 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1abb : 48              >            pha         ;use stack to load status
1abc : 28              >            plp
                        
1abd : a982                     lda #$82
1abf : 08                       php
1ac0 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1ac3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ac6 : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1ac8 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1acb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1acd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1acf : 48              >            pha         ;use stack to load status
1ad0 : 28              >            plp
                        
1ad1 : a941                     lda #$41
1ad3 : 08                       php
1ad4 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
1ad7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ad9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ada : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1adc : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1adf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ae1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1ae3 : 48              >            pha         ;use stack to load status
1ae4 : 28              >            plp
                        
1ae5 : a900                     lda #0
1ae7 : 08                       php
1ae8 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
1aeb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aed : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1aee : 4979            >            eor #(lo~fnz &m8i|fao)   ;mask I, invert expected flags + always on bits
                        
1af0 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1af3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1af5 : a200                     ldx #0
1af7 : a50c                     lda zpt  
1af9 : 49c3                     eor #$c3
1afb : c515                     cmp zp1  
                                trap_ne     ;store to zp data
1afd : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aff : 860c                     stx zpt     ;clear                
1b01 : ad0302                   lda abst  
1b04 : 49c3                     eor #$c3
1b06 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
1b09 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b0b : 8e0302                   stx abst    ;clear                
1b0e : a50d                     lda zpt+1
1b10 : 49c3                     eor #$c3
1b12 : c516                     cmp zp1+1
                                trap_ne     ;store to zp data
1b14 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b16 : 860d                     stx zpt+1   ;clear                
1b18 : ad0402                   lda abst+1
1b1b : 49c3                     eor #$c3
1b1d : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
1b20 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b22 : 8e0402                   stx abst+1  ;clear                
1b25 : a50e                     lda zpt+2
1b27 : 49c3                     eor #$c3
1b29 : c517                     cmp zp1+2
                                trap_ne     ;store to zp data
1b2b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b2d : 860e                     stx zpt+2   ;clear                
1b2f : ad0502                   lda abst+2
1b32 : 49c3                     eor #$c3
1b34 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1b37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b39 : 8e0502                   stx abst+2  ;clear                
1b3c : a50f                     lda zpt+3
1b3e : 49c3                     eor #$c3
1b40 : c518                     cmp zp1+3
                                trap_ne     ;store to zp data
1b42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b44 : 860f                     stx zpt+3   ;clear                
1b46 : ad0602                   lda abst+3
1b49 : 49c3                     eor #$c3
1b4b : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b4e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b50 : 8e0602                   stx abst+3  ;clear                
                                next_test
1b53 : ad0002          >            lda test_case   ;previous test
1b56 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b5a : a919            >            lda #test_num   ;*** next tests' number
1b5c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b5f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1b61 : 48              >            pha         ;use stack to load status
1b62 : a9ff            >            lda #$ff     ;precharge accu
1b64 : 28              >            plp
                        
1b65 : 2418                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b67 : 08              >            php         ;save flags
1b68 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6c : 68              >            pla         ;load status
1b6d : 48              >            pha
                       >            cmp_flag fz 
1b6e : c932            >            cmp #(fz |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1b70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b72 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b73 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1b75 : 48              >            pha         ;use stack to load status
1b76 : a901            >            lda #1     ;precharge accu
1b78 : 28              >            plp
                        
1b79 : 2417                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b7b : 08              >            php         ;save flags
1b7c : c901            >            cmp #1     ;test result
                       >            trap_ne
1b7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b80 : 68              >            pla         ;load status
1b81 : 48              >            pha
                       >            cmp_flag fv
1b82 : c970            >            cmp #(fv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1b84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b86 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b87 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1b89 : 48              >            pha         ;use stack to load status
1b8a : a901            >            lda #1     ;precharge accu
1b8c : 28              >            plp
                        
1b8d : 2416                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b8f : 08              >            php         ;save flags
1b90 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b94 : 68              >            pla         ;load status
1b95 : 48              >            pha
                       >            cmp_flag fnz
1b96 : c9b2            >            cmp #(fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1b98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b9a : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b9b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1b9d : 48              >            pha         ;use stack to load status
1b9e : a901            >            lda #1     ;precharge accu
1ba0 : 28              >            plp
                        
1ba1 : 2415                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1ba3 : 08              >            php         ;save flags
1ba4 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ba6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba8 : 68              >            pla         ;load status
1ba9 : 48              >            pha
                       >            cmp_flag fnv
1baa : c9f0            >            cmp #(fnv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1bac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bae : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1baf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1bb1 : 48              >            pha         ;use stack to load status
1bb2 : a9ff            >            lda #$ff     ;precharge accu
1bb4 : 28              >            plp
                        
1bb5 : 2418                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1bb7 : 08              >            php         ;save flags
1bb8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bbc : 68              >            pla         ;load status
1bbd : 48              >            pha
                       >            cmp_flag ~fnv 
1bbe : c93b            >            cmp #(~fnv |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1bc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc2 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bc3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1bc5 : 48              >            pha         ;use stack to load status
1bc6 : a901            >            lda #1     ;precharge accu
1bc8 : 28              >            plp
                        
1bc9 : 2417                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1bcb : 08              >            php         ;save flags
1bcc : c901            >            cmp #1     ;test result
                       >            trap_ne
1bce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd0 : 68              >            pla         ;load status
1bd1 : 48              >            pha
                       >            cmp_flag ~fnz
1bd2 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1bd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd6 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bd7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1bd9 : 48              >            pha         ;use stack to load status
1bda : a901            >            lda #1     ;precharge accu
1bdc : 28              >            plp
                        
1bdd : 2416                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1bdf : 08              >            php         ;save flags
1be0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1be2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be4 : 68              >            pla         ;load status
1be5 : 48              >            pha
                       >            cmp_flag ~fv
1be6 : c9bb            >            cmp #(~fv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1be8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bea : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1beb : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1bed : 48              >            pha         ;use stack to load status
1bee : a901            >            lda #1     ;precharge accu
1bf0 : 28              >            plp
                        
1bf1 : 2415                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1bf3 : 08              >            php         ;save flags
1bf4 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bf6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bf8 : 68              >            pla         ;load status
1bf9 : 48              >            pha
                       >            cmp_flag ~fz
1bfa : c9f9            >            cmp #(~fz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1bfc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfe : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1bff : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1c01 : 48              >            pha         ;use stack to load status
1c02 : a9ff            >            lda #$ff     ;precharge accu
1c04 : 28              >            plp
                        
1c05 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1c08 : 08              >            php         ;save flags
1c09 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c0d : 68              >            pla         ;load status
1c0e : 48              >            pha
                       >            cmp_flag fz 
1c0f : c932            >            cmp #(fz |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c13 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c14 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1c16 : 48              >            pha         ;use stack to load status
1c17 : a901            >            lda #1     ;precharge accu
1c19 : 28              >            plp
                        
1c1a : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1c1d : 08              >            php         ;save flags
1c1e : c901            >            cmp #1     ;test result
                       >            trap_ne
1c20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c22 : 68              >            pla         ;load status
1c23 : 48              >            pha
                       >            cmp_flag fv
1c24 : c970            >            cmp #(fv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c28 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c29 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1c2b : 48              >            pha         ;use stack to load status
1c2c : a901            >            lda #1     ;precharge accu
1c2e : 28              >            plp
                        
1c2f : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1c32 : 08              >            php         ;save flags
1c33 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c37 : 68              >            pla         ;load status
1c38 : 48              >            pha
                       >            cmp_flag fnz
1c39 : c9b2            >            cmp #(fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c3e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1c40 : 48              >            pha         ;use stack to load status
1c41 : a901            >            lda #1     ;precharge accu
1c43 : 28              >            plp
                        
1c44 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c47 : 08              >            php         ;save flags
1c48 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4c : 68              >            pla         ;load status
1c4d : 48              >            pha
                       >            cmp_flag fnv
1c4e : c9f0            >            cmp #(fnv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c52 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c53 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c55 : 48              >            pha         ;use stack to load status
1c56 : a9ff            >            lda #$ff     ;precharge accu
1c58 : 28              >            plp
                        
1c59 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c5c : 08              >            php         ;save flags
1c5d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c61 : 68              >            pla         ;load status
1c62 : 48              >            pha
                       >            cmp_flag ~fnv 
1c63 : c93b            >            cmp #(~fnv |fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c67 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c68 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c6a : 48              >            pha         ;use stack to load status
1c6b : a901            >            lda #1     ;precharge accu
1c6d : 28              >            plp
                        
1c6e : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c71 : 08              >            php         ;save flags
1c72 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c76 : 68              >            pla         ;load status
1c77 : 48              >            pha
                       >            cmp_flag ~fnz
1c78 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c7c : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c7d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c7f : 48              >            pha         ;use stack to load status
1c80 : a901            >            lda #1     ;precharge accu
1c82 : 28              >            plp
                        
1c83 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c86 : 08              >            php         ;save flags
1c87 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c8b : 68              >            pla         ;load status
1c8c : 48              >            pha
                       >            cmp_flag ~fv
1c8d : c9bb            >            cmp #(~fv|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1c8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c91 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c92 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c94 : 48              >            pha         ;use stack to load status
1c95 : a901            >            lda #1     ;precharge accu
1c97 : 28              >            plp
                        
1c98 : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c9b : 08              >            php         ;save flags
1c9c : c901            >            cmp #1     ;test result
                       >            trap_ne
1c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca0 : 68              >            pla         ;load status
1ca1 : 48              >            pha
                       >            cmp_flag ~fz
1ca2 : c9f9            >            cmp #(~fz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca6 : 28              >            plp         ;restore status
                        
                                next_test
1ca7 : ad0002          >            lda test_case   ;previous test
1caa : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1cac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1cae : a91a            >            lda #test_num   ;*** next tests' number
1cb0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1cb3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1cb5 : 48              >            pha         ;use stack to load status
1cb6 : a280            >            ldx #$80     ;precharge index x
1cb8 : 28              >            plp
                        
1cb9 : e419                     cpx zp7f
                                tst_stat fc
1cbb : 08              >            php         ;save status
1cbc : 68              >            pla         ;use stack to retrieve status
1cbd : 48              >            pha
                       >            cmp_flag fc
1cbe : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc2 : 28              >            plp         ;restore status
                        
1cc3 : ca                       dex
1cc4 : e419                     cpx zp7f
                                tst_stat fzc
1cc6 : 08              >            php         ;save status
1cc7 : 68              >            pla         ;use stack to retrieve status
1cc8 : 48              >            pha
                       >            cmp_flag fzc
1cc9 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ccb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ccd : 28              >            plp         ;restore status
                        
1cce : ca                       dex
1ccf : e419                     cpx zp7f
                                tst_x $7e,fn
1cd1 : 08              >            php         ;save flags
1cd2 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd6 : 68              >            pla         ;load status
1cd7 : 48              >            pha
                       >            cmp_flag fn
1cd8 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cdc : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cdd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1cdf : 48              >            pha         ;use stack to load status
1ce0 : a280            >            ldx #$80     ;precharge index x
1ce2 : 28              >            plp
                        
1ce3 : e419                     cpx zp7f
                                tst_stat ~fnz
1ce5 : 08              >            php         ;save status
1ce6 : 68              >            pla         ;use stack to retrieve status
1ce7 : 48              >            pha
                       >            cmp_flag ~fnz
1ce8 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cec : 28              >            plp         ;restore status
                        
1ced : ca                       dex
1cee : e419                     cpx zp7f
                                tst_stat ~fn
1cf0 : 08              >            php         ;save status
1cf1 : 68              >            pla         ;use stack to retrieve status
1cf2 : 48              >            pha
                       >            cmp_flag ~fn
1cf3 : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf7 : 28              >            plp         ;restore status
                        
1cf8 : ca                       dex
1cf9 : e419                     cpx zp7f
                                tst_x $7e,~fzc
1cfb : 08              >            php         ;save flags
1cfc : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d00 : 68              >            pla         ;load status
1d01 : 48              >            pha
                       >            cmp_flag ~fzc
1d02 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d06 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d07 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1d09 : 48              >            pha         ;use stack to load status
1d0a : a280            >            ldx #$80     ;precharge index x
1d0c : 28              >            plp
                        
1d0d : ec1c02                   cpx abs7f
                                tst_stat fc
1d10 : 08              >            php         ;save status
1d11 : 68              >            pla         ;use stack to retrieve status
1d12 : 48              >            pha
                       >            cmp_flag fc
1d13 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d17 : 28              >            plp         ;restore status
                        
1d18 : ca                       dex
1d19 : ec1c02                   cpx abs7f
                                tst_stat fzc
1d1c : 08              >            php         ;save status
1d1d : 68              >            pla         ;use stack to retrieve status
1d1e : 48              >            pha
                       >            cmp_flag fzc
1d1f : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d23 : 28              >            plp         ;restore status
                        
1d24 : ca                       dex
1d25 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
1d28 : 08              >            php         ;save flags
1d29 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d2d : 68              >            pla         ;load status
1d2e : 48              >            pha
                       >            cmp_flag fn
1d2f : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d33 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d34 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d36 : 48              >            pha         ;use stack to load status
1d37 : a280            >            ldx #$80     ;precharge index x
1d39 : 28              >            plp
                        
1d3a : ec1c02                   cpx abs7f
                                tst_stat ~fnz
1d3d : 08              >            php         ;save status
1d3e : 68              >            pla         ;use stack to retrieve status
1d3f : 48              >            pha
                       >            cmp_flag ~fnz
1d40 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d44 : 28              >            plp         ;restore status
                        
1d45 : ca                       dex
1d46 : ec1c02                   cpx abs7f
                                tst_stat ~fn
1d49 : 08              >            php         ;save status
1d4a : 68              >            pla         ;use stack to retrieve status
1d4b : 48              >            pha
                       >            cmp_flag ~fn
1d4c : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d50 : 28              >            plp         ;restore status
                        
1d51 : ca                       dex
1d52 : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
1d55 : 08              >            php         ;save flags
1d56 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5a : 68              >            pla         ;load status
1d5b : 48              >            pha
                       >            cmp_flag ~fzc
1d5c : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d60 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d61 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1d63 : 48              >            pha         ;use stack to load status
1d64 : a280            >            ldx #$80     ;precharge index x
1d66 : 28              >            plp
                        
1d67 : e07f                     cpx #$7f
                                tst_stat fc
1d69 : 08              >            php         ;save status
1d6a : 68              >            pla         ;use stack to retrieve status
1d6b : 48              >            pha
                       >            cmp_flag fc
1d6c : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d70 : 28              >            plp         ;restore status
                        
1d71 : ca                       dex
1d72 : e07f                     cpx #$7f
                                tst_stat fzc
1d74 : 08              >            php         ;save status
1d75 : 68              >            pla         ;use stack to retrieve status
1d76 : 48              >            pha
                       >            cmp_flag fzc
1d77 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d7b : 28              >            plp         ;restore status
                        
1d7c : ca                       dex
1d7d : e07f                     cpx #$7f
                                tst_x $7e,fn
1d7f : 08              >            php         ;save flags
1d80 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d84 : 68              >            pla         ;load status
1d85 : 48              >            pha
                       >            cmp_flag fn
1d86 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d8a : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d8b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d8d : 48              >            pha         ;use stack to load status
1d8e : a280            >            ldx #$80     ;precharge index x
1d90 : 28              >            plp
                        
1d91 : e07f                     cpx #$7f
                                tst_stat ~fnz
1d93 : 08              >            php         ;save status
1d94 : 68              >            pla         ;use stack to retrieve status
1d95 : 48              >            pha
                       >            cmp_flag ~fnz
1d96 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d9a : 28              >            plp         ;restore status
                        
1d9b : ca                       dex
1d9c : e07f                     cpx #$7f
                                tst_stat ~fn
1d9e : 08              >            php         ;save status
1d9f : 68              >            pla         ;use stack to retrieve status
1da0 : 48              >            pha
                       >            cmp_flag ~fn
1da1 : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1da3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da5 : 28              >            plp         ;restore status
                        
1da6 : ca                       dex
1da7 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1da9 : 08              >            php         ;save flags
1daa : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1dac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dae : 68              >            pla         ;load status
1daf : 48              >            pha
                       >            cmp_flag ~fzc
1db0 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1db2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db4 : 28              >            plp         ;restore status
                        
                                next_test
1db5 : ad0002          >            lda test_case   ;previous test
1db8 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1dba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1dbc : a91b            >            lda #test_num   ;*** next tests' number
1dbe : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1dc1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1dc3 : 48              >            pha         ;use stack to load status
1dc4 : a080            >            ldy #$80     ;precharge index y
1dc6 : 28              >            plp
                        
1dc7 : c419                     cpy zp7f
                                tst_stat fc
1dc9 : 08              >            php         ;save status
1dca : 68              >            pla         ;use stack to retrieve status
1dcb : 48              >            pha
                       >            cmp_flag fc
1dcc : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1dce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd0 : 28              >            plp         ;restore status
                        
1dd1 : 88                       dey
1dd2 : c419                     cpy zp7f
                                tst_stat fzc
1dd4 : 08              >            php         ;save status
1dd5 : 68              >            pla         ;use stack to retrieve status
1dd6 : 48              >            pha
                       >            cmp_flag fzc
1dd7 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1dd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ddb : 28              >            plp         ;restore status
                        
1ddc : 88                       dey
1ddd : c419                     cpy zp7f
                                tst_y $7e,fn
1ddf : 08              >            php         ;save flags
1de0 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1de2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de4 : 68              >            pla         ;load status
1de5 : 48              >            pha
                       >            cmp_flag fn
1de6 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1de8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dea : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1deb : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1ded : 48              >            pha         ;use stack to load status
1dee : a080            >            ldy #$80     ;precharge index y
1df0 : 28              >            plp
                        
1df1 : c419                     cpy zp7f
                                tst_stat ~fnz
1df3 : 08              >            php         ;save status
1df4 : 68              >            pla         ;use stack to retrieve status
1df5 : 48              >            pha
                       >            cmp_flag ~fnz
1df6 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1df8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfa : 28              >            plp         ;restore status
                        
1dfb : 88                       dey
1dfc : c419                     cpy zp7f
                                tst_stat ~fn
1dfe : 08              >            php         ;save status
1dff : 68              >            pla         ;use stack to retrieve status
1e00 : 48              >            pha
                       >            cmp_flag ~fn
1e01 : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e05 : 28              >            plp         ;restore status
                        
1e06 : 88                       dey
1e07 : c419                     cpy zp7f
                                tst_y $7e,~fzc
1e09 : 08              >            php         ;save flags
1e0a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e0e : 68              >            pla         ;load status
1e0f : 48              >            pha
                       >            cmp_flag ~fzc
1e10 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e14 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e15 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1e17 : 48              >            pha         ;use stack to load status
1e18 : a080            >            ldy #$80     ;precharge index y
1e1a : 28              >            plp
                        
1e1b : cc1c02                   cpy abs7f
                                tst_stat fc
1e1e : 08              >            php         ;save status
1e1f : 68              >            pla         ;use stack to retrieve status
1e20 : 48              >            pha
                       >            cmp_flag fc
1e21 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e25 : 28              >            plp         ;restore status
                        
1e26 : 88                       dey
1e27 : cc1c02                   cpy abs7f
                                tst_stat fzc
1e2a : 08              >            php         ;save status
1e2b : 68              >            pla         ;use stack to retrieve status
1e2c : 48              >            pha
                       >            cmp_flag fzc
1e2d : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e31 : 28              >            plp         ;restore status
                        
1e32 : 88                       dey
1e33 : cc1c02                   cpy abs7f
                                tst_y $7e,fn
1e36 : 08              >            php         ;save flags
1e37 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3b : 68              >            pla         ;load status
1e3c : 48              >            pha
                       >            cmp_flag fn
1e3d : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e3f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e41 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e42 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1e44 : 48              >            pha         ;use stack to load status
1e45 : a080            >            ldy #$80     ;precharge index y
1e47 : 28              >            plp
                        
1e48 : cc1c02                   cpy abs7f
                                tst_stat ~fnz
1e4b : 08              >            php         ;save status
1e4c : 68              >            pla         ;use stack to retrieve status
1e4d : 48              >            pha
                       >            cmp_flag ~fnz
1e4e : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e52 : 28              >            plp         ;restore status
                        
1e53 : 88                       dey
1e54 : cc1c02                   cpy abs7f
                                tst_stat ~fn
1e57 : 08              >            php         ;save status
1e58 : 68              >            pla         ;use stack to retrieve status
1e59 : 48              >            pha
                       >            cmp_flag ~fn
1e5a : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e5e : 28              >            plp         ;restore status
                        
1e5f : 88                       dey
1e60 : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
1e63 : 08              >            php         ;save flags
1e64 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e68 : 68              >            pla         ;load status
1e69 : 48              >            pha
                       >            cmp_flag ~fzc
1e6a : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e6e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e6f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1e71 : 48              >            pha         ;use stack to load status
1e72 : a080            >            ldy #$80     ;precharge index y
1e74 : 28              >            plp
                        
1e75 : c07f                     cpy #$7f
                                tst_stat fc
1e77 : 08              >            php         ;save status
1e78 : 68              >            pla         ;use stack to retrieve status
1e79 : 48              >            pha
                       >            cmp_flag fc
1e7a : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7e : 28              >            plp         ;restore status
                        
1e7f : 88                       dey
1e80 : c07f                     cpy #$7f
                                tst_stat fzc
1e82 : 08              >            php         ;save status
1e83 : 68              >            pla         ;use stack to retrieve status
1e84 : 48              >            pha
                       >            cmp_flag fzc
1e85 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e89 : 28              >            plp         ;restore status
                        
1e8a : 88                       dey
1e8b : c07f                     cpy #$7f
                                tst_y $7e,fn
1e8d : 08              >            php         ;save flags
1e8e : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e92 : 68              >            pla         ;load status
1e93 : 48              >            pha
                       >            cmp_flag fn
1e94 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e98 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e99 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1e9b : 48              >            pha         ;use stack to load status
1e9c : a080            >            ldy #$80     ;precharge index y
1e9e : 28              >            plp
                        
1e9f : c07f                     cpy #$7f
                                tst_stat ~fnz
1ea1 : 08              >            php         ;save status
1ea2 : 68              >            pla         ;use stack to retrieve status
1ea3 : 48              >            pha
                       >            cmp_flag ~fnz
1ea4 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ea6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea8 : 28              >            plp         ;restore status
                        
1ea9 : 88                       dey
1eaa : c07f                     cpy #$7f
                                tst_stat ~fn
1eac : 08              >            php         ;save status
1ead : 68              >            pla         ;use stack to retrieve status
1eae : 48              >            pha
                       >            cmp_flag ~fn
1eaf : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1eb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb3 : 28              >            plp         ;restore status
                        
1eb4 : 88                       dey
1eb5 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1eb7 : 08              >            php         ;save flags
1eb8 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1eba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ebc : 68              >            pla         ;load status
1ebd : 48              >            pha
                       >            cmp_flag ~fzc
1ebe : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ec0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec2 : 28              >            plp         ;restore status
                        
                                next_test
1ec3 : ad0002          >            lda test_case   ;previous test
1ec6 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1ec8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1eca : a91c            >            lda #test_num   ;*** next tests' number
1ecc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1ecf : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1ed1 : 48              >            pha         ;use stack to load status
1ed2 : a980            >            lda #$80     ;precharge accu
1ed4 : 28              >            plp
                        
1ed5 : c519                     cmp zp7f
                                tst_a $80,fc
1ed7 : 08              >            php         ;save flags
1ed8 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edc : 68              >            pla         ;load status
1edd : 48              >            pha
                       >            cmp_flag fc
1ede : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ee0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee2 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ee3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1ee5 : 48              >            pha         ;use stack to load status
1ee6 : a97f            >            lda #$7f     ;precharge accu
1ee8 : 28              >            plp
                        
1ee9 : c519                     cmp zp7f
                                tst_a $7f,fzc
1eeb : 08              >            php         ;save flags
1eec : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1eee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef0 : 68              >            pla         ;load status
1ef1 : 48              >            pha
                       >            cmp_flag fzc
1ef2 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ef4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef6 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ef7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1ef9 : 48              >            pha         ;use stack to load status
1efa : a97e            >            lda #$7e     ;precharge accu
1efc : 28              >            plp
                        
1efd : c519                     cmp zp7f
                                tst_a $7e,fn
1eff : 08              >            php         ;save flags
1f00 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f04 : 68              >            pla         ;load status
1f05 : 48              >            pha
                       >            cmp_flag fn
1f06 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f0b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f0d : 48              >            pha         ;use stack to load status
1f0e : a980            >            lda #$80     ;precharge accu
1f10 : 28              >            plp
                        
1f11 : c519                     cmp zp7f
                                tst_a $80,~fnz
1f13 : 08              >            php         ;save flags
1f14 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f18 : 68              >            pla         ;load status
1f19 : 48              >            pha
                       >            cmp_flag ~fnz
1f1a : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f1f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f21 : 48              >            pha         ;use stack to load status
1f22 : a97f            >            lda #$7f     ;precharge accu
1f24 : 28              >            plp
                        
1f25 : c519                     cmp zp7f
                                tst_a $7f,~fn
1f27 : 08              >            php         ;save flags
1f28 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2c : 68              >            pla         ;load status
1f2d : 48              >            pha
                       >            cmp_flag ~fn
1f2e : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f32 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f33 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f35 : 48              >            pha         ;use stack to load status
1f36 : a97e            >            lda #$7e     ;precharge accu
1f38 : 28              >            plp
                        
1f39 : c519                     cmp zp7f
                                tst_a $7e,~fzc
1f3b : 08              >            php         ;save flags
1f3c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f40 : 68              >            pla         ;load status
1f41 : 48              >            pha
                       >            cmp_flag ~fzc
1f42 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f46 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f47 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1f49 : 48              >            pha         ;use stack to load status
1f4a : a980            >            lda #$80     ;precharge accu
1f4c : 28              >            plp
                        
1f4d : cd1c02                   cmp abs7f
                                tst_a $80,fc
1f50 : 08              >            php         ;save flags
1f51 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f55 : 68              >            pla         ;load status
1f56 : 48              >            pha
                       >            cmp_flag fc
1f57 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f5c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1f5e : 48              >            pha         ;use stack to load status
1f5f : a97f            >            lda #$7f     ;precharge accu
1f61 : 28              >            plp
                        
1f62 : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
1f65 : 08              >            php         ;save flags
1f66 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6a : 68              >            pla         ;load status
1f6b : 48              >            pha
                       >            cmp_flag fzc
1f6c : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f70 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f71 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1f73 : 48              >            pha         ;use stack to load status
1f74 : a97e            >            lda #$7e     ;precharge accu
1f76 : 28              >            plp
                        
1f77 : cd1c02                   cmp abs7f
                                tst_a $7e,fn
1f7a : 08              >            php         ;save flags
1f7b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f7f : 68              >            pla         ;load status
1f80 : 48              >            pha
                       >            cmp_flag fn
1f81 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f85 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f86 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f88 : 48              >            pha         ;use stack to load status
1f89 : a980            >            lda #$80     ;precharge accu
1f8b : 28              >            plp
                        
1f8c : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
1f8f : 08              >            php         ;save flags
1f90 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f94 : 68              >            pla         ;load status
1f95 : 48              >            pha
                       >            cmp_flag ~fnz
1f96 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f9b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f9d : 48              >            pha         ;use stack to load status
1f9e : a97f            >            lda #$7f     ;precharge accu
1fa0 : 28              >            plp
                        
1fa1 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
1fa4 : 08              >            php         ;save flags
1fa5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fa7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fa9 : 68              >            pla         ;load status
1faa : 48              >            pha
                       >            cmp_flag ~fn
1fab : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1fb0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1fb2 : 48              >            pha         ;use stack to load status
1fb3 : a97e            >            lda #$7e     ;precharge accu
1fb5 : 28              >            plp
                        
1fb6 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
1fb9 : 08              >            php         ;save flags
1fba : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbe : 68              >            pla         ;load status
1fbf : 48              >            pha
                       >            cmp_flag ~fzc
1fc0 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc4 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1fc5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1fc7 : 48              >            pha         ;use stack to load status
1fc8 : a980            >            lda #$80     ;precharge accu
1fca : 28              >            plp
                        
1fcb : c97f                     cmp #$7f
                                tst_a $80,fc
1fcd : 08              >            php         ;save flags
1fce : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd2 : 68              >            pla         ;load status
1fd3 : 48              >            pha
                       >            cmp_flag fc
1fd4 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd8 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1fd9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1fdb : 48              >            pha         ;use stack to load status
1fdc : a97f            >            lda #$7f     ;precharge accu
1fde : 28              >            plp
                        
1fdf : c97f                     cmp #$7f
                                tst_a $7f,fzc
1fe1 : 08              >            php         ;save flags
1fe2 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fe4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe6 : 68              >            pla         ;load status
1fe7 : 48              >            pha
                       >            cmp_flag fzc
1fe8 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fec : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fed : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1fef : 48              >            pha         ;use stack to load status
1ff0 : a97e            >            lda #$7e     ;precharge accu
1ff2 : 28              >            plp
                        
1ff3 : c97f                     cmp #$7f
                                tst_a $7e,fn
1ff5 : 08              >            php         ;save flags
1ff6 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1ff8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffa : 68              >            pla         ;load status
1ffb : 48              >            pha
                       >            cmp_flag fn
1ffc : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ffe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2000 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2001 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2003 : 48              >            pha         ;use stack to load status
2004 : a980            >            lda #$80     ;precharge accu
2006 : 28              >            plp
                        
2007 : c97f                     cmp #$7f
                                tst_a $80,~fnz
2009 : 08              >            php         ;save flags
200a : c980            >            cmp #$80     ;test result
                       >            trap_ne
200c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200e : 68              >            pla         ;load status
200f : 48              >            pha
                       >            cmp_flag ~fnz
2010 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2012 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2014 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2015 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2017 : 48              >            pha         ;use stack to load status
2018 : a97f            >            lda #$7f     ;precharge accu
201a : 28              >            plp
                        
201b : c97f                     cmp #$7f
                                tst_a $7f,~fn
201d : 08              >            php         ;save flags
201e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2020 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2022 : 68              >            pla         ;load status
2023 : 48              >            pha
                       >            cmp_flag ~fn
2024 : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2026 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2028 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2029 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
202b : 48              >            pha         ;use stack to load status
202c : a97e            >            lda #$7e     ;precharge accu
202e : 28              >            plp
                        
202f : c97f                     cmp #$7f
                                tst_a $7e,~fzc
2031 : 08              >            php         ;save flags
2032 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2034 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2036 : 68              >            pla         ;load status
2037 : 48              >            pha
                       >            cmp_flag ~fzc
2038 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
203a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203c : 28              >            plp         ;restore status
                        
                        
203d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
203f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2041 : 48              >            pha         ;use stack to load status
2042 : a980            >            lda #$80     ;precharge accu
2044 : 28              >            plp
                        
2045 : d515                     cmp zp1,x
                                tst_a $80,fc
2047 : 08              >            php         ;save flags
2048 : c980            >            cmp #$80     ;test result
                       >            trap_ne
204a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204c : 68              >            pla         ;load status
204d : 48              >            pha
                       >            cmp_flag fc
204e : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2050 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2052 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2053 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2055 : 48              >            pha         ;use stack to load status
2056 : a97f            >            lda #$7f     ;precharge accu
2058 : 28              >            plp
                        
2059 : d515                     cmp zp1,x
                                tst_a $7f,fzc
205b : 08              >            php         ;save flags
205c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
205e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2060 : 68              >            pla         ;load status
2061 : 48              >            pha
                       >            cmp_flag fzc
2062 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2064 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2066 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2067 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2069 : 48              >            pha         ;use stack to load status
206a : a97e            >            lda #$7e     ;precharge accu
206c : 28              >            plp
                        
206d : d515                     cmp zp1,x
                                tst_a $7e,fn
206f : 08              >            php         ;save flags
2070 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2072 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2074 : 68              >            pla         ;load status
2075 : 48              >            pha
                       >            cmp_flag fn
2076 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2078 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
207b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
207d : 48              >            pha         ;use stack to load status
207e : a980            >            lda #$80     ;precharge accu
2080 : 28              >            plp
                        
2081 : d515                     cmp zp1,x
                                tst_a $80,~fnz
2083 : 08              >            php         ;save flags
2084 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2086 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2088 : 68              >            pla         ;load status
2089 : 48              >            pha
                       >            cmp_flag ~fnz
208a : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
208c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
208f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2091 : 48              >            pha         ;use stack to load status
2092 : a97f            >            lda #$7f     ;precharge accu
2094 : 28              >            plp
                        
2095 : d515                     cmp zp1,x
                                tst_a $7f,~fn
2097 : 08              >            php         ;save flags
2098 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
209a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209c : 68              >            pla         ;load status
209d : 48              >            pha
                       >            cmp_flag ~fn
209e : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20a3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
20a5 : 48              >            pha         ;use stack to load status
20a6 : a97e            >            lda #$7e     ;precharge accu
20a8 : 28              >            plp
                        
20a9 : d515                     cmp zp1,x
                                tst_a $7e,~fzc
20ab : 08              >            php         ;save flags
20ac : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b0 : 68              >            pla         ;load status
20b1 : 48              >            pha
                       >            cmp_flag ~fzc
20b2 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20b7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
20b9 : 48              >            pha         ;use stack to load status
20ba : a980            >            lda #$80     ;precharge accu
20bc : 28              >            plp
                        
20bd : dd1802                   cmp abs1,x
                                tst_a $80,fc
20c0 : 08              >            php         ;save flags
20c1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c5 : 68              >            pla         ;load status
20c6 : 48              >            pha
                       >            cmp_flag fc
20c7 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20cb : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20cc : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
20ce : 48              >            pha         ;use stack to load status
20cf : a97f            >            lda #$7f     ;precharge accu
20d1 : 28              >            plp
                        
20d2 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
20d5 : 08              >            php         ;save flags
20d6 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20da : 68              >            pla         ;load status
20db : 48              >            pha
                       >            cmp_flag fzc
20dc : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20e1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
20e3 : 48              >            pha         ;use stack to load status
20e4 : a97e            >            lda #$7e     ;precharge accu
20e6 : 28              >            plp
                        
20e7 : dd1802                   cmp abs1,x
                                tst_a $7e,fn
20ea : 08              >            php         ;save flags
20eb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ef : 68              >            pla         ;load status
20f0 : 48              >            pha
                       >            cmp_flag fn
20f1 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f5 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20f6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
20f8 : 48              >            pha         ;use stack to load status
20f9 : a980            >            lda #$80     ;precharge accu
20fb : 28              >            plp
                        
20fc : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
20ff : 08              >            php         ;save flags
2100 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2102 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2104 : 68              >            pla         ;load status
2105 : 48              >            pha
                       >            cmp_flag ~fnz
2106 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2108 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
210b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
210d : 48              >            pha         ;use stack to load status
210e : a97f            >            lda #$7f     ;precharge accu
2110 : 28              >            plp
                        
2111 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
2114 : 08              >            php         ;save flags
2115 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2117 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2119 : 68              >            pla         ;load status
211a : 48              >            pha
                       >            cmp_flag ~fn
211b : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
211d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2120 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2122 : 48              >            pha         ;use stack to load status
2123 : a97e            >            lda #$7e     ;precharge accu
2125 : 28              >            plp
                        
2126 : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
2129 : 08              >            php         ;save flags
212a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
212c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
212e : 68              >            pla         ;load status
212f : 48              >            pha
                       >            cmp_flag ~fzc
2130 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2132 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2134 : 28              >            plp         ;restore status
                        
                        
2135 : a004                     ldy #4          ;with indexing by Y
2137 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2139 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
213b : 48              >            pha         ;use stack to load status
213c : a980            >            lda #$80     ;precharge accu
213e : 28              >            plp
                        
213f : d91802                   cmp abs1,y
                                tst_a $80,fc
2142 : 08              >            php         ;save flags
2143 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2145 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2147 : 68              >            pla         ;load status
2148 : 48              >            pha
                       >            cmp_flag fc
2149 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
214b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
214e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2150 : 48              >            pha         ;use stack to load status
2151 : a97f            >            lda #$7f     ;precharge accu
2153 : 28              >            plp
                        
2154 : d91802                   cmp abs1,y
                                tst_a $7f,fzc
2157 : 08              >            php         ;save flags
2158 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
215a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215c : 68              >            pla         ;load status
215d : 48              >            pha
                       >            cmp_flag fzc
215e : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2160 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2162 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2163 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2165 : 48              >            pha         ;use stack to load status
2166 : a97e            >            lda #$7e     ;precharge accu
2168 : 28              >            plp
                        
2169 : d91802                   cmp abs1,y
                                tst_a $7e,fn
216c : 08              >            php         ;save flags
216d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
216f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2171 : 68              >            pla         ;load status
2172 : 48              >            pha
                       >            cmp_flag fn
2173 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2175 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2177 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2178 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
217a : 48              >            pha         ;use stack to load status
217b : a980            >            lda #$80     ;precharge accu
217d : 28              >            plp
                        
217e : d91802                   cmp abs1,y
                                tst_a $80,~fnz
2181 : 08              >            php         ;save flags
2182 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2184 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2186 : 68              >            pla         ;load status
2187 : 48              >            pha
                       >            cmp_flag ~fnz
2188 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
218a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
218d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
218f : 48              >            pha         ;use stack to load status
2190 : a97f            >            lda #$7f     ;precharge accu
2192 : 28              >            plp
                        
2193 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
2196 : 08              >            php         ;save flags
2197 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2199 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219b : 68              >            pla         ;load status
219c : 48              >            pha
                       >            cmp_flag ~fn
219d : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
219f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a1 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21a2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
21a4 : 48              >            pha         ;use stack to load status
21a5 : a97e            >            lda #$7e     ;precharge accu
21a7 : 28              >            plp
                        
21a8 : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
21ab : 08              >            php         ;save flags
21ac : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b0 : 68              >            pla         ;load status
21b1 : 48              >            pha
                       >            cmp_flag ~fzc
21b2 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21b7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21b9 : 48              >            pha         ;use stack to load status
21ba : a980            >            lda #$80     ;precharge accu
21bc : 28              >            plp
                        
21bd : c126                     cmp (ind1,x)
                                tst_a $80,fc
21bf : 08              >            php         ;save flags
21c0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c4 : 68              >            pla         ;load status
21c5 : 48              >            pha
                       >            cmp_flag fc
21c6 : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ca : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21cb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21cd : 48              >            pha         ;use stack to load status
21ce : a97f            >            lda #$7f     ;precharge accu
21d0 : 28              >            plp
                        
21d1 : c126                     cmp (ind1,x)
                                tst_a $7f,fzc
21d3 : 08              >            php         ;save flags
21d4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d8 : 68              >            pla         ;load status
21d9 : 48              >            pha
                       >            cmp_flag fzc
21da : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21de : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21df : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21e1 : 48              >            pha         ;use stack to load status
21e2 : a97e            >            lda #$7e     ;precharge accu
21e4 : 28              >            plp
                        
21e5 : c126                     cmp (ind1,x)
                                tst_a $7e,fn
21e7 : 08              >            php         ;save flags
21e8 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ec : 68              >            pla         ;load status
21ed : 48              >            pha
                       >            cmp_flag fn
21ee : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f2 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21f3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
21f5 : 48              >            pha         ;use stack to load status
21f6 : a980            >            lda #$80     ;precharge accu
21f8 : 28              >            plp
                        
21f9 : c126                     cmp (ind1,x)
                                tst_a $80,~fnz
21fb : 08              >            php         ;save flags
21fc : c980            >            cmp #$80     ;test result
                       >            trap_ne
21fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2200 : 68              >            pla         ;load status
2201 : 48              >            pha
                       >            cmp_flag ~fnz
2202 : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2204 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2206 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2207 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2209 : 48              >            pha         ;use stack to load status
220a : a97f            >            lda #$7f     ;precharge accu
220c : 28              >            plp
                        
220d : c126                     cmp (ind1,x)
                                tst_a $7f,~fn
220f : 08              >            php         ;save flags
2210 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2212 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2214 : 68              >            pla         ;load status
2215 : 48              >            pha
                       >            cmp_flag ~fn
2216 : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2218 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221a : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
221b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
221d : 48              >            pha         ;use stack to load status
221e : a97e            >            lda #$7e     ;precharge accu
2220 : 28              >            plp
                        
2221 : c126                     cmp (ind1,x)
                                tst_a $7e,~fzc
2223 : 08              >            php         ;save flags
2224 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2226 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2228 : 68              >            pla         ;load status
2229 : 48              >            pha
                       >            cmp_flag ~fzc
222a : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
222c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
222f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2231 : 48              >            pha         ;use stack to load status
2232 : a980            >            lda #$80     ;precharge accu
2234 : 28              >            plp
                        
2235 : d126                     cmp (ind1),y
                                tst_a $80,fc
2237 : 08              >            php         ;save flags
2238 : c980            >            cmp #$80     ;test result
                       >            trap_ne
223a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223c : 68              >            pla         ;load status
223d : 48              >            pha
                       >            cmp_flag fc
223e : c931            >            cmp #(fc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2240 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2242 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2243 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2245 : 48              >            pha         ;use stack to load status
2246 : a97f            >            lda #$7f     ;precharge accu
2248 : 28              >            plp
                        
2249 : d126                     cmp (ind1),y
                                tst_a $7f,fzc
224b : 08              >            php         ;save flags
224c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
224e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2250 : 68              >            pla         ;load status
2251 : 48              >            pha
                       >            cmp_flag fzc
2252 : c933            >            cmp #(fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2254 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2256 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2257 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2259 : 48              >            pha         ;use stack to load status
225a : a97e            >            lda #$7e     ;precharge accu
225c : 28              >            plp
                        
225d : d126                     cmp (ind1),y
                                tst_a $7e,fn
225f : 08              >            php         ;save flags
2260 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2262 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2264 : 68              >            pla         ;load status
2265 : 48              >            pha
                       >            cmp_flag fn
2266 : c9b0            >            cmp #(fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2268 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
226b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
226d : 48              >            pha         ;use stack to load status
226e : a980            >            lda #$80     ;precharge accu
2270 : 28              >            plp
                        
2271 : d126                     cmp (ind1),y
                                tst_a $80,~fnz
2273 : 08              >            php         ;save flags
2274 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2276 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2278 : 68              >            pla         ;load status
2279 : 48              >            pha
                       >            cmp_flag ~fnz
227a : c979            >            cmp #(~fnz|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
227c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
227f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2281 : 48              >            pha         ;use stack to load status
2282 : a97f            >            lda #$7f     ;precharge accu
2284 : 28              >            plp
                        
2285 : d126                     cmp (ind1),y
                                tst_a $7f,~fn
2287 : 08              >            php         ;save flags
2288 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
228a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
228c : 68              >            pla         ;load status
228d : 48              >            pha
                       >            cmp_flag ~fn
228e : c97b            >            cmp #(~fn|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2290 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2292 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2293 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2295 : 48              >            pha         ;use stack to load status
2296 : a97e            >            lda #$7e     ;precharge accu
2298 : 28              >            plp
                        
2299 : d126                     cmp (ind1),y
                                tst_a $7e,~fzc
229b : 08              >            php         ;save flags
229c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
229e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a0 : 68              >            pla         ;load status
22a1 : 48              >            pha
                       >            cmp_flag ~fzc
22a2 : c9f8            >            cmp #(~fzc|fao)&m8i   ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
22a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a6 : 28              >            plp         ;restore status
                        
                                next_test
22a7 : ad0002          >            lda test_case   ;previous test
22aa : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
22ae : a91d            >            lda #test_num   ;*** next tests' number
22b0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
22b3 : a205                     ldx #5
22b5 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
22b5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
22b7 : 48              >            pha         ;use stack to load status
22b8 : b513            >            lda zps,x    ;precharge accu
22ba : 28              >            plp
                        
22bb : 0a                       asl a
                                tst_ax rASL,fASL,0
22bc : 08              >            php         ;save flags
22bd : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
22c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c2 : 68              >            pla         ;load status
                       >            eor_flag 0
22c3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
22c5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22ca : ca                       dex
22cb : 10e8                     bpl tasl
22cd : a205                     ldx #5
22cf :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
22cf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
22d1 : 48              >            pha         ;use stack to load status
22d2 : b513            >            lda zps,x    ;precharge accu
22d4 : 28              >            plp
                        
22d5 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
22d6 : 08              >            php         ;save flags
22d7 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
22da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22dc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22dd : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
22df : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22e4 : ca                       dex
22e5 : 10e8                     bpl tasl1
                        
22e7 : a205                     ldx #5
22e9 :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
22e9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
22eb : 48              >            pha         ;use stack to load status
22ec : b513            >            lda zps,x    ;precharge accu
22ee : 28              >            plp
                        
22ef : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
22f0 : 08              >            php         ;save flags
22f1 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
22f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22f6 : 68              >            pla         ;load status
                       >            eor_flag 0
22f7 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
22f9 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22fe : ca                       dex
22ff : 10e8                     bpl tlsr
2301 : a205                     ldx #5
2303 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
2303 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2305 : 48              >            pha         ;use stack to load status
2306 : b513            >            lda zps,x    ;precharge accu
2308 : 28              >            plp
                        
2309 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
230a : 08              >            php         ;save flags
230b : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
230e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2310 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2311 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2313 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2316 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2318 : ca                       dex
2319 : 10e8                     bpl tlsr1
                        
231b : a205                     ldx #5
231d :                  trol
                                set_ax zps,0
                       >            load_flag 0
231d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
231f : 48              >            pha         ;use stack to load status
2320 : b513            >            lda zps,x    ;precharge accu
2322 : 28              >            plp
                        
2323 : 2a                       rol a
                                tst_ax rROL,fROL,0
2324 : 08              >            php         ;save flags
2325 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2328 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
232a : 68              >            pla         ;load status
                       >            eor_flag 0
232b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
232d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2330 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2332 : ca                       dex
2333 : 10e8                     bpl trol
2335 : a205                     ldx #5
2337 :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
2337 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2339 : 48              >            pha         ;use stack to load status
233a : b513            >            lda zps,x    ;precharge accu
233c : 28              >            plp
                        
233d : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
233e : 08              >            php         ;save flags
233f : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2342 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2344 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2345 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2347 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
234a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
234c : ca                       dex
234d : 10e8                     bpl trol1
                        
234f : a205                     ldx #5
2351 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
2351 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2353 : 48              >            pha         ;use stack to load status
2354 : b513            >            lda zps,x    ;precharge accu
2356 : 28              >            plp
                        
2357 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2358 : 08              >            php         ;save flags
2359 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
235c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
235e : 68              >            pla         ;load status
                       >            eor_flag 0
235f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2361 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2364 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2366 : ca                       dex
2367 : 10e8                     bpl trolc
2369 : a205                     ldx #5
236b :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
236b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
236d : 48              >            pha         ;use stack to load status
236e : b513            >            lda zps,x    ;precharge accu
2370 : 28              >            plp
                        
2371 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
2372 : 08              >            php         ;save flags
2373 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2376 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2378 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2379 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
237b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
237e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2380 : ca                       dex
2381 : 10e8                     bpl trolc1
                        
2383 : a205                     ldx #5
2385 :                  tror
                                set_ax zps,0
                       >            load_flag 0
2385 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2387 : 48              >            pha         ;use stack to load status
2388 : b513            >            lda zps,x    ;precharge accu
238a : 28              >            plp
                        
238b : 6a                       ror a
                                tst_ax rROR,fROR,0
238c : 08              >            php         ;save flags
238d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2390 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2392 : 68              >            pla         ;load status
                       >            eor_flag 0
2393 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2395 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2398 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
239a : ca                       dex
239b : 10e8                     bpl tror
239d : a205                     ldx #5
239f :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
239f : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
23a1 : 48              >            pha         ;use stack to load status
23a2 : b513            >            lda zps,x    ;precharge accu
23a4 : 28              >            plp
                        
23a5 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
23a6 : 08              >            php         ;save flags
23a7 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
23aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23ad : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
23af : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
23b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23b4 : ca                       dex
23b5 : 10e8                     bpl tror1
                        
23b7 : a205                     ldx #5
23b9 :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
23b9 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
23bb : 48              >            pha         ;use stack to load status
23bc : b513            >            lda zps,x    ;precharge accu
23be : 28              >            plp
                        
23bf : 6a                       ror a
                                tst_ax rRORc,fRORc,0
23c0 : 08              >            php         ;save flags
23c1 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
23c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23c6 : 68              >            pla         ;load status
                       >            eor_flag 0
23c7 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
23c9 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23ce : ca                       dex
23cf : 10e8                     bpl trorc
23d1 : a205                     ldx #5
23d3 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
23d3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
23d5 : 48              >            pha         ;use stack to load status
23d6 : b513            >            lda zps,x    ;precharge accu
23d8 : 28              >            plp
                        
23d9 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
23da : 08              >            php         ;save flags
23db : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
23de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23e1 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
23e3 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23e8 : ca                       dex
23e9 : 10e8                     bpl trorc1
                                next_test
23eb : ad0002          >            lda test_case   ;previous test
23ee : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
23f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
23f2 : a91e            >            lda #test_num   ;*** next tests' number
23f4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
23f7 : a205                     ldx #5
23f9 :                  tasl2
                                set_z zps,0
                       >            load_flag 0
23f9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
23fb : 48              >            pha         ;use stack to load status
23fc : b513            >            lda zps,x    ;load to zeropage
23fe : 850c            >            sta zpt
2400 : 28              >            plp
                        
2401 : 060c                     asl zpt
                                tst_z rASL,fASL,0
2403 : 08              >            php         ;save flags
2404 : a50c            >            lda zpt
2406 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2409 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
240b : 68              >            pla         ;load status
                       >            eor_flag 0
240c : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
240e : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2411 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2413 : ca                       dex
2414 : 10e3                     bpl tasl2
2416 : a205                     ldx #5
2418 :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
2418 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
241a : 48              >            pha         ;use stack to load status
241b : b513            >            lda zps,x    ;load to zeropage
241d : 850c            >            sta zpt
241f : 28              >            plp
                        
2420 : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2422 : 08              >            php         ;save flags
2423 : a50c            >            lda zpt
2425 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2428 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
242a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
242b : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
242d : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2430 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2432 : ca                       dex
2433 : 10e3                     bpl tasl3
                        
2435 : a205                     ldx #5
2437 :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
2437 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2439 : 48              >            pha         ;use stack to load status
243a : b513            >            lda zps,x    ;load to zeropage
243c : 850c            >            sta zpt
243e : 28              >            plp
                        
243f : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
2441 : 08              >            php         ;save flags
2442 : a50c            >            lda zpt
2444 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2447 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2449 : 68              >            pla         ;load status
                       >            eor_flag 0
244a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
244c : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
244f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2451 : ca                       dex
2452 : 10e3                     bpl tlsr2
2454 : a205                     ldx #5
2456 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
2456 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2458 : 48              >            pha         ;use stack to load status
2459 : b513            >            lda zps,x    ;load to zeropage
245b : 850c            >            sta zpt
245d : 28              >            plp
                        
245e : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2460 : 08              >            php         ;save flags
2461 : a50c            >            lda zpt
2463 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2466 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2468 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2469 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
246b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
246e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2470 : ca                       dex
2471 : 10e3                     bpl tlsr3
                        
2473 : a205                     ldx #5
2475 :                  trol2
                                set_z zps,0
                       >            load_flag 0
2475 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2477 : 48              >            pha         ;use stack to load status
2478 : b513            >            lda zps,x    ;load to zeropage
247a : 850c            >            sta zpt
247c : 28              >            plp
                        
247d : 260c                     rol zpt
                                tst_z rROL,fROL,0
247f : 08              >            php         ;save flags
2480 : a50c            >            lda zpt
2482 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2485 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2487 : 68              >            pla         ;load status
                       >            eor_flag 0
2488 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
248a : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
248d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
248f : ca                       dex
2490 : 10e3                     bpl trol2
2492 : a205                     ldx #5
2494 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2494 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2496 : 48              >            pha         ;use stack to load status
2497 : b513            >            lda zps,x    ;load to zeropage
2499 : 850c            >            sta zpt
249b : 28              >            plp
                        
249c : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
249e : 08              >            php         ;save flags
249f : a50c            >            lda zpt
24a1 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
24a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24a6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24a7 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
24a9 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
24ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24ae : ca                       dex
24af : 10e3                     bpl trol3
                        
24b1 : a205                     ldx #5
24b3 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
24b3 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
24b5 : 48              >            pha         ;use stack to load status
24b6 : b513            >            lda zps,x    ;load to zeropage
24b8 : 850c            >            sta zpt
24ba : 28              >            plp
                        
24bb : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
24bd : 08              >            php         ;save flags
24be : a50c            >            lda zpt
24c0 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
24c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24c5 : 68              >            pla         ;load status
                       >            eor_flag 0
24c6 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
24c8 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24cd : ca                       dex
24ce : 10e3                     bpl trolc2
24d0 : a205                     ldx #5
24d2 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
24d2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
24d4 : 48              >            pha         ;use stack to load status
24d5 : b513            >            lda zps,x    ;load to zeropage
24d7 : 850c            >            sta zpt
24d9 : 28              >            plp
                        
24da : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
24dc : 08              >            php         ;save flags
24dd : a50c            >            lda zpt
24df : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
24e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24e4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24e5 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
24e7 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24ec : ca                       dex
24ed : 10e3                     bpl trolc3
                        
24ef : a205                     ldx #5
24f1 :                  tror2
                                set_z zps,0
                       >            load_flag 0
24f1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
24f3 : 48              >            pha         ;use stack to load status
24f4 : b513            >            lda zps,x    ;load to zeropage
24f6 : 850c            >            sta zpt
24f8 : 28              >            plp
                        
24f9 : 660c                     ror zpt
                                tst_z rROR,fROR,0
24fb : 08              >            php         ;save flags
24fc : a50c            >            lda zpt
24fe : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2501 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2503 : 68              >            pla         ;load status
                       >            eor_flag 0
2504 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2506 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2509 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
250b : ca                       dex
250c : 10e3                     bpl tror2
250e : a205                     ldx #5
2510 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2510 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2512 : 48              >            pha         ;use stack to load status
2513 : b513            >            lda zps,x    ;load to zeropage
2515 : 850c            >            sta zpt
2517 : 28              >            plp
                        
2518 : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
251a : 08              >            php         ;save flags
251b : a50c            >            lda zpt
251d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2520 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2522 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2523 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2525 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2528 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
252a : ca                       dex
252b : 10e3                     bpl tror3
                        
252d : a205                     ldx #5
252f :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
252f : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2531 : 48              >            pha         ;use stack to load status
2532 : b513            >            lda zps,x    ;load to zeropage
2534 : 850c            >            sta zpt
2536 : 28              >            plp
                        
2537 : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
2539 : 08              >            php         ;save flags
253a : a50c            >            lda zpt
253c : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
253f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2541 : 68              >            pla         ;load status
                       >            eor_flag 0
2542 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2544 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2547 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2549 : ca                       dex
254a : 10e3                     bpl trorc2
254c : a205                     ldx #5
254e :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
254e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2550 : 48              >            pha         ;use stack to load status
2551 : b513            >            lda zps,x    ;load to zeropage
2553 : 850c            >            sta zpt
2555 : 28              >            plp
                        
2556 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2558 : 08              >            php         ;save flags
2559 : a50c            >            lda zpt
255b : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
255e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2560 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2561 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2563 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2566 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2568 : ca                       dex
2569 : 10e3                     bpl trorc3
                                next_test
256b : ad0002          >            lda test_case   ;previous test
256e : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2570 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
2572 : a91f            >            lda #test_num   ;*** next tests' number
2574 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2577 : a205                     ldx #5
2579 :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
2579 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
257b : 48              >            pha         ;use stack to load status
257c : b513            >            lda zps,x    ;load to memory
257e : 8d0302          >            sta abst
2581 : 28              >            plp
                        
2582 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2585 : 08              >            php         ;save flags
2586 : ad0302          >            lda abst
2589 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
258c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
258e : 68              >            pla         ;load status
                       >            eor_flag 0
258f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2591 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2594 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2596 : ca                       dex
2597 : 10e0                     bpl tasl4
2599 : a205                     ldx #5
259b :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
259b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
259d : 48              >            pha         ;use stack to load status
259e : b513            >            lda zps,x    ;load to memory
25a0 : 8d0302          >            sta abst
25a3 : 28              >            plp
                        
25a4 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
25a7 : 08              >            php         ;save flags
25a8 : ad0302          >            lda abst
25ab : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
25ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25b1 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
25b3 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
25b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25b8 : ca                       dex
25b9 : 10e0                     bpl tasl5
                        
25bb : a205                     ldx #5
25bd :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
25bd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
25bf : 48              >            pha         ;use stack to load status
25c0 : b513            >            lda zps,x    ;load to memory
25c2 : 8d0302          >            sta abst
25c5 : 28              >            plp
                        
25c6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
25c9 : 08              >            php         ;save flags
25ca : ad0302          >            lda abst
25cd : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
25d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25d2 : 68              >            pla         ;load status
                       >            eor_flag 0
25d3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
25d5 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25da : ca                       dex
25db : 10e0                     bpl tlsr4
25dd : a205                     ldx #5
25df :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
25df : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
25e1 : 48              >            pha         ;use stack to load status
25e2 : b513            >            lda zps,x    ;load to memory
25e4 : 8d0302          >            sta abst
25e7 : 28              >            plp
                        
25e8 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
25eb : 08              >            php         ;save flags
25ec : ad0302          >            lda abst
25ef : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
25f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25f5 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
25f7 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25fc : ca                       dex
25fd : 10e0                     bpl tlsr5
                        
25ff : a205                     ldx #5
2601 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
2601 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2603 : 48              >            pha         ;use stack to load status
2604 : b513            >            lda zps,x    ;load to memory
2606 : 8d0302          >            sta abst
2609 : 28              >            plp
                        
260a : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
260d : 08              >            php         ;save flags
260e : ad0302          >            lda abst
2611 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2614 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2616 : 68              >            pla         ;load status
                       >            eor_flag 0
2617 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2619 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
261c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
261e : ca                       dex
261f : 10e0                     bpl trol4
2621 : a205                     ldx #5
2623 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
2623 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2625 : 48              >            pha         ;use stack to load status
2626 : b513            >            lda zps,x    ;load to memory
2628 : 8d0302          >            sta abst
262b : 28              >            plp
                        
262c : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
262f : 08              >            php         ;save flags
2630 : ad0302          >            lda abst
2633 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2636 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2638 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2639 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
263b : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
263e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2640 : ca                       dex
2641 : 10e0                     bpl trol5
                        
2643 : a205                     ldx #5
2645 :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
2645 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2647 : 48              >            pha         ;use stack to load status
2648 : b513            >            lda zps,x    ;load to memory
264a : 8d0302          >            sta abst
264d : 28              >            plp
                        
264e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2651 : 08              >            php         ;save flags
2652 : ad0302          >            lda abst
2655 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2658 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
265a : 68              >            pla         ;load status
                       >            eor_flag 0
265b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
265d : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2660 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2662 : ca                       dex
2663 : 10e0                     bpl trolc4
2665 : a205                     ldx #5
2667 :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
2667 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2669 : 48              >            pha         ;use stack to load status
266a : b513            >            lda zps,x    ;load to memory
266c : 8d0302          >            sta abst
266f : 28              >            plp
                        
2670 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2673 : 08              >            php         ;save flags
2674 : ad0302          >            lda abst
2677 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
267a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
267c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
267d : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
267f : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2682 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2684 : ca                       dex
2685 : 10e0                     bpl trolc5
                        
2687 : a205                     ldx #5
2689 :                  tror4
                                set_abs zps,0
                       >            load_flag 0
2689 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
268b : 48              >            pha         ;use stack to load status
268c : b513            >            lda zps,x    ;load to memory
268e : 8d0302          >            sta abst
2691 : 28              >            plp
                        
2692 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2695 : 08              >            php         ;save flags
2696 : ad0302          >            lda abst
2699 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
269c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
269e : 68              >            pla         ;load status
                       >            eor_flag 0
269f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
26a1 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
26a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26a6 : ca                       dex
26a7 : 10e0                     bpl tror4
26a9 : a205                     ldx #5
26ab :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
26ab : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
26ad : 48              >            pha         ;use stack to load status
26ae : b513            >            lda zps,x    ;load to memory
26b0 : 8d0302          >            sta abst
26b3 : 28              >            plp
                        
26b4 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
26b7 : 08              >            php         ;save flags
26b8 : ad0302          >            lda abst
26bb : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
26be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26c0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26c1 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
26c3 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
26c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26c8 : ca                       dex
26c9 : 10e0                     bpl tror5
                        
26cb : a205                     ldx #5
26cd :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
26cd : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
26cf : 48              >            pha         ;use stack to load status
26d0 : b513            >            lda zps,x    ;load to memory
26d2 : 8d0302          >            sta abst
26d5 : 28              >            plp
                        
26d6 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
26d9 : 08              >            php         ;save flags
26da : ad0302          >            lda abst
26dd : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
26e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26e2 : 68              >            pla         ;load status
                       >            eor_flag 0
26e3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
26e5 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26ea : ca                       dex
26eb : 10e0                     bpl trorc4
26ed : a205                     ldx #5
26ef :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
26ef : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
26f1 : 48              >            pha         ;use stack to load status
26f2 : b513            >            lda zps,x    ;load to memory
26f4 : 8d0302          >            sta abst
26f7 : 28              >            plp
                        
26f8 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
26fb : 08              >            php         ;save flags
26fc : ad0302          >            lda abst
26ff : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2702 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2704 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2705 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2707 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
270a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
270c : ca                       dex
270d : 10e0                     bpl trorc5
                                next_test
270f : ad0002          >            lda test_case   ;previous test
2712 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2714 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2716 : a920            >            lda #test_num   ;*** next tests' number
2718 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
271b : a205                     ldx #5
271d :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
271d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
271f : 48              >            pha         ;use stack to load status
2720 : b513            >            lda zps,x    ;load to indexed zeropage
2722 : 950c            >            sta zpt,x
2724 : 28              >            plp
                        
2725 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
2727 : 08              >            php         ;save flags
2728 : b50c            >            lda zpt,x
272a : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
272d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
272f : 68              >            pla         ;load status
                       >            eor_flag 0
2730 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2732 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2735 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2737 : ca                       dex
2738 : 10e3                     bpl tasl6
273a : a205                     ldx #5
273c :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
273c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
273e : 48              >            pha         ;use stack to load status
273f : b513            >            lda zps,x    ;load to indexed zeropage
2741 : 950c            >            sta zpt,x
2743 : 28              >            plp
                        
2744 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2746 : 08              >            php         ;save flags
2747 : b50c            >            lda zpt,x
2749 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
274c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
274e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
274f : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2751 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2754 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2756 : ca                       dex
2757 : 10e3                     bpl tasl7
                        
2759 : a205                     ldx #5
275b :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
275b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
275d : 48              >            pha         ;use stack to load status
275e : b513            >            lda zps,x    ;load to indexed zeropage
2760 : 950c            >            sta zpt,x
2762 : 28              >            plp
                        
2763 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2765 : 08              >            php         ;save flags
2766 : b50c            >            lda zpt,x
2768 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
276b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
276d : 68              >            pla         ;load status
                       >            eor_flag 0
276e : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2770 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2773 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2775 : ca                       dex
2776 : 10e3                     bpl tlsr6
2778 : a205                     ldx #5
277a :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
277a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
277c : 48              >            pha         ;use stack to load status
277d : b513            >            lda zps,x    ;load to indexed zeropage
277f : 950c            >            sta zpt,x
2781 : 28              >            plp
                        
2782 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2784 : 08              >            php         ;save flags
2785 : b50c            >            lda zpt,x
2787 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
278a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
278c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
278d : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
278f : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2792 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2794 : ca                       dex
2795 : 10e3                     bpl tlsr7
                        
2797 : a205                     ldx #5
2799 :                  trol6
                                set_zx zps,0
                       >            load_flag 0
2799 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
279b : 48              >            pha         ;use stack to load status
279c : b513            >            lda zps,x    ;load to indexed zeropage
279e : 950c            >            sta zpt,x
27a0 : 28              >            plp
                        
27a1 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
27a3 : 08              >            php         ;save flags
27a4 : b50c            >            lda zpt,x
27a6 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
27a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ab : 68              >            pla         ;load status
                       >            eor_flag 0
27ac : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
27ae : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
27b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27b3 : ca                       dex
27b4 : 10e3                     bpl trol6
27b6 : a205                     ldx #5
27b8 :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
27b8 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
27ba : 48              >            pha         ;use stack to load status
27bb : b513            >            lda zps,x    ;load to indexed zeropage
27bd : 950c            >            sta zpt,x
27bf : 28              >            plp
                        
27c0 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
27c2 : 08              >            php         ;save flags
27c3 : b50c            >            lda zpt,x
27c5 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
27c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ca : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27cb : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
27cd : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
27d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27d2 : ca                       dex
27d3 : 10e3                     bpl trol7
                        
27d5 : a205                     ldx #5
27d7 :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
27d7 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
27d9 : 48              >            pha         ;use stack to load status
27da : b513            >            lda zps,x    ;load to indexed zeropage
27dc : 950c            >            sta zpt,x
27de : 28              >            plp
                        
27df : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
27e1 : 08              >            php         ;save flags
27e2 : b50c            >            lda zpt,x
27e4 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
27e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27e9 : 68              >            pla         ;load status
                       >            eor_flag 0
27ea : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
27ec : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27f1 : ca                       dex
27f2 : 10e3                     bpl trolc6
27f4 : a205                     ldx #5
27f6 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
27f6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
27f8 : 48              >            pha         ;use stack to load status
27f9 : b513            >            lda zps,x    ;load to indexed zeropage
27fb : 950c            >            sta zpt,x
27fd : 28              >            plp
                        
27fe : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
2800 : 08              >            php         ;save flags
2801 : b50c            >            lda zpt,x
2803 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2806 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2808 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2809 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
280b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
280e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2810 : ca                       dex
2811 : 10e3                     bpl trolc7
                        
2813 : a205                     ldx #5
2815 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
2815 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2817 : 48              >            pha         ;use stack to load status
2818 : b513            >            lda zps,x    ;load to indexed zeropage
281a : 950c            >            sta zpt,x
281c : 28              >            plp
                        
281d : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
281f : 08              >            php         ;save flags
2820 : b50c            >            lda zpt,x
2822 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2825 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2827 : 68              >            pla         ;load status
                       >            eor_flag 0
2828 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
282a : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
282d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
282f : ca                       dex
2830 : 10e3                     bpl tror6
2832 : a205                     ldx #5
2834 :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
2834 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2836 : 48              >            pha         ;use stack to load status
2837 : b513            >            lda zps,x    ;load to indexed zeropage
2839 : 950c            >            sta zpt,x
283b : 28              >            plp
                        
283c : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
283e : 08              >            php         ;save flags
283f : b50c            >            lda zpt,x
2841 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2844 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2846 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2847 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2849 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
284c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
284e : ca                       dex
284f : 10e3                     bpl tror7
                        
2851 : a205                     ldx #5
2853 :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
2853 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2855 : 48              >            pha         ;use stack to load status
2856 : b513            >            lda zps,x    ;load to indexed zeropage
2858 : 950c            >            sta zpt,x
285a : 28              >            plp
                        
285b : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
285d : 08              >            php         ;save flags
285e : b50c            >            lda zpt,x
2860 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2863 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2865 : 68              >            pla         ;load status
                       >            eor_flag 0
2866 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2868 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
286b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
286d : ca                       dex
286e : 10e3                     bpl trorc6
2870 : a205                     ldx #5
2872 :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
2872 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2874 : 48              >            pha         ;use stack to load status
2875 : b513            >            lda zps,x    ;load to indexed zeropage
2877 : 950c            >            sta zpt,x
2879 : 28              >            plp
                        
287a : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
287c : 08              >            php         ;save flags
287d : b50c            >            lda zpt,x
287f : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2882 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2884 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2885 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2887 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
288a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
288c : ca                       dex
288d : 10e3                     bpl trorc7
                                next_test
288f : ad0002          >            lda test_case   ;previous test
2892 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2894 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2896 : a921            >            lda #test_num   ;*** next tests' number
2898 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
289b : a205                     ldx #5
289d :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
289d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
289f : 48              >            pha         ;use stack to load status
28a0 : b513            >            lda zps,x    ;load to indexed memory
28a2 : 9d0302          >            sta abst,x
28a5 : 28              >            plp
                        
28a6 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
28a9 : 08              >            php         ;save flags
28aa : bd0302          >            lda abst,x
28ad : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
28b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28b2 : 68              >            pla         ;load status
                       >            eor_flag 0
28b3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
28b5 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
28b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28ba : ca                       dex
28bb : 10e0                     bpl tasl8
28bd : a205                     ldx #5
28bf :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
28bf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
28c1 : 48              >            pha         ;use stack to load status
28c2 : b513            >            lda zps,x    ;load to indexed memory
28c4 : 9d0302          >            sta abst,x
28c7 : 28              >            plp
                        
28c8 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
28cb : 08              >            php         ;save flags
28cc : bd0302          >            lda abst,x
28cf : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
28d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28d4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28d5 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
28d7 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
28da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28dc : ca                       dex
28dd : 10e0                     bpl tasl9
                        
28df : a205                     ldx #5
28e1 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
28e1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
28e3 : 48              >            pha         ;use stack to load status
28e4 : b513            >            lda zps,x    ;load to indexed memory
28e6 : 9d0302          >            sta abst,x
28e9 : 28              >            plp
                        
28ea : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
28ed : 08              >            php         ;save flags
28ee : bd0302          >            lda abst,x
28f1 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
28f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28f6 : 68              >            pla         ;load status
                       >            eor_flag 0
28f7 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
28f9 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28fe : ca                       dex
28ff : 10e0                     bpl tlsr8
2901 : a205                     ldx #5
2903 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
2903 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2905 : 48              >            pha         ;use stack to load status
2906 : b513            >            lda zps,x    ;load to indexed memory
2908 : 9d0302          >            sta abst,x
290b : 28              >            plp
                        
290c : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
290f : 08              >            php         ;save flags
2910 : bd0302          >            lda abst,x
2913 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2916 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2918 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2919 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
291b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
291e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2920 : ca                       dex
2921 : 10e0                     bpl tlsr9
                        
2923 : a205                     ldx #5
2925 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
2925 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2927 : 48              >            pha         ;use stack to load status
2928 : b513            >            lda zps,x    ;load to indexed memory
292a : 9d0302          >            sta abst,x
292d : 28              >            plp
                        
292e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2931 : 08              >            php         ;save flags
2932 : bd0302          >            lda abst,x
2935 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2938 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
293a : 68              >            pla         ;load status
                       >            eor_flag 0
293b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
293d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2940 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2942 : ca                       dex
2943 : 10e0                     bpl trol8
2945 : a205                     ldx #5
2947 :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
2947 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2949 : 48              >            pha         ;use stack to load status
294a : b513            >            lda zps,x    ;load to indexed memory
294c : 9d0302          >            sta abst,x
294f : 28              >            plp
                        
2950 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2953 : 08              >            php         ;save flags
2954 : bd0302          >            lda abst,x
2957 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
295a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
295c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
295d : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
295f : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2962 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2964 : ca                       dex
2965 : 10e0                     bpl trol9
                        
2967 : a205                     ldx #5
2969 :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
2969 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
296b : 48              >            pha         ;use stack to load status
296c : b513            >            lda zps,x    ;load to indexed memory
296e : 9d0302          >            sta abst,x
2971 : 28              >            plp
                        
2972 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2975 : 08              >            php         ;save flags
2976 : bd0302          >            lda abst,x
2979 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
297c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
297e : 68              >            pla         ;load status
                       >            eor_flag 0
297f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2981 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2984 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2986 : ca                       dex
2987 : 10e0                     bpl trolc8
2989 : a205                     ldx #5
298b :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
298b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
298d : 48              >            pha         ;use stack to load status
298e : b513            >            lda zps,x    ;load to indexed memory
2990 : 9d0302          >            sta abst,x
2993 : 28              >            plp
                        
2994 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2997 : 08              >            php         ;save flags
2998 : bd0302          >            lda abst,x
299b : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
299e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29a0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29a1 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
29a3 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
29a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29a8 : ca                       dex
29a9 : 10e0                     bpl trolc9
                        
29ab : a205                     ldx #5
29ad :                  tror8
                                set_absx zps,0
                       >            load_flag 0
29ad : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
29af : 48              >            pha         ;use stack to load status
29b0 : b513            >            lda zps,x    ;load to indexed memory
29b2 : 9d0302          >            sta abst,x
29b5 : 28              >            plp
                        
29b6 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
29b9 : 08              >            php         ;save flags
29ba : bd0302          >            lda abst,x
29bd : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
29c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c2 : 68              >            pla         ;load status
                       >            eor_flag 0
29c3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
29c5 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
29c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ca : ca                       dex
29cb : 10e0                     bpl tror8
29cd : a205                     ldx #5
29cf :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
29cf : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
29d1 : 48              >            pha         ;use stack to load status
29d2 : b513            >            lda zps,x    ;load to indexed memory
29d4 : 9d0302          >            sta abst,x
29d7 : 28              >            plp
                        
29d8 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
29db : 08              >            php         ;save flags
29dc : bd0302          >            lda abst,x
29df : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
29e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29e4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29e5 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
29e7 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
29ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ec : ca                       dex
29ed : 10e0                     bpl tror9
                        
29ef : a205                     ldx #5
29f1 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
29f1 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
29f3 : 48              >            pha         ;use stack to load status
29f4 : b513            >            lda zps,x    ;load to indexed memory
29f6 : 9d0302          >            sta abst,x
29f9 : 28              >            plp
                        
29fa : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
29fd : 08              >            php         ;save flags
29fe : bd0302          >            lda abst,x
2a01 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a06 : 68              >            pla         ;load status
                       >            eor_flag 0
2a07 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2a09 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a0e : ca                       dex
2a0f : 10e0                     bpl trorc8
2a11 : a205                     ldx #5
2a13 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
2a13 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2a15 : 48              >            pha         ;use stack to load status
2a16 : b513            >            lda zps,x    ;load to indexed memory
2a18 : 9d0302          >            sta abst,x
2a1b : 28              >            plp
                        
2a1c : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2a1f : 08              >            php         ;save flags
2a20 : bd0302          >            lda abst,x
2a23 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a28 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a29 : 4978            >            eor #($ff-fnzc&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2a2b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a30 : ca                       dex
2a31 : 10e0                     bpl trorc9
                                next_test
2a33 : ad0002          >            lda test_case   ;previous test
2a36 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2a3a : a922            >            lda #test_num   ;*** next tests' number
2a3c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a3f : a200                     ldx #0
2a41 : a97e                     lda #$7e
2a43 : 850c                     sta zpt
2a45 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a45 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2a47 : 48              >            pha         ;use stack to load status
2a48 : 28              >            plp
                        
2a49 : e60c                     inc zpt
                                tst_z rINC,fINC,0
2a4b : 08              >            php         ;save flags
2a4c : a50c            >            lda zpt
2a4e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a53 : 68              >            pla         ;load status
                       >            eor_flag 0
2a54 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2a56 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a5b : e8                       inx
2a5c : e002                     cpx #2
2a5e : d004                     bne tinc1
2a60 : a9fe                     lda #$fe
2a62 : 850c                     sta zpt
2a64 : e005             tinc1   cpx #5
2a66 : d0dd                     bne tinc
2a68 : ca                       dex
2a69 : e60c                     inc zpt
2a6b :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a6b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2a6d : 48              >            pha         ;use stack to load status
2a6e : 28              >            plp
                        
2a6f : c60c                     dec zpt
                                tst_z rINC,fINC,0
2a71 : 08              >            php         ;save flags
2a72 : a50c            >            lda zpt
2a74 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2a77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a79 : 68              >            pla         ;load status
                       >            eor_flag 0
2a7a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2a7c : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a81 : ca                       dex
2a82 : 300a                     bmi tdec1
2a84 : e001                     cpx #1
2a86 : d0e3                     bne tdec
2a88 : a981                     lda #$81
2a8a : 850c                     sta zpt
2a8c : d0dd                     bne tdec
2a8e :                  tdec1
2a8e : a200                     ldx #0
2a90 : a97e                     lda #$7e
2a92 : 850c                     sta zpt
2a94 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a94 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2a96 : 48              >            pha         ;use stack to load status
2a97 : 28              >            plp
                        
2a98 : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a9a : 08              >            php         ;save flags
2a9b : a50c            >            lda zpt
2a9d : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2aa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aa2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2aa3 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2aa5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2aaa : e8                       inx
2aab : e002                     cpx #2
2aad : d004                     bne tinc11
2aaf : a9fe                     lda #$fe
2ab1 : 850c                     sta zpt
2ab3 : e005             tinc11  cpx #5
2ab5 : d0dd                     bne tinc10
2ab7 : ca                       dex
2ab8 : e60c                     inc zpt
2aba :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2aba : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2abc : 48              >            pha         ;use stack to load status
2abd : 28              >            plp
                        
2abe : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2ac0 : 08              >            php         ;save flags
2ac1 : a50c            >            lda zpt
2ac3 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ac6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ac8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ac9 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2acb : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ace : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ad0 : ca                       dex
2ad1 : 300a                     bmi tdec11
2ad3 : e001                     cpx #1
2ad5 : d0e3                     bne tdec10
2ad7 : a981                     lda #$81
2ad9 : 850c                     sta zpt
2adb : d0dd                     bne tdec10
2add :                  tdec11
                                next_test
2add : ad0002          >            lda test_case   ;previous test
2ae0 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2ae2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2ae4 : a923            >            lda #test_num   ;*** next tests' number
2ae6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2ae9 : a200                     ldx #0
2aeb : a97e                     lda #$7e
2aed : 8d0302                   sta abst
2af0 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2af0 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2af2 : 48              >            pha         ;use stack to load status
2af3 : 28              >            plp
                        
2af4 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2af7 : 08              >            php         ;save flags
2af8 : ad0302          >            lda abst
2afb : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2afe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b00 : 68              >            pla         ;load status
                       >            eor_flag 0
2b01 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2b03 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b08 : e8                       inx
2b09 : e002                     cpx #2
2b0b : d005                     bne tinc3
2b0d : a9fe                     lda #$fe
2b0f : 8d0302                   sta abst
2b12 : e005             tinc3   cpx #5
2b14 : d0da                     bne tinc2
2b16 : ca                       dex
2b17 : ee0302                   inc abst
2b1a :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2b1a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2b1c : 48              >            pha         ;use stack to load status
2b1d : 28              >            plp
                        
2b1e : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2b21 : 08              >            php         ;save flags
2b22 : ad0302          >            lda abst
2b25 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b2a : 68              >            pla         ;load status
                       >            eor_flag 0
2b2b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2b2d : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b32 : ca                       dex
2b33 : 300b                     bmi tdec3
2b35 : e001                     cpx #1
2b37 : d0e1                     bne tdec2
2b39 : a981                     lda #$81
2b3b : 8d0302                   sta abst
2b3e : d0da                     bne tdec2
2b40 :                  tdec3
2b40 : a200                     ldx #0
2b42 : a97e                     lda #$7e
2b44 : 8d0302                   sta abst
2b47 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b47 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2b49 : 48              >            pha         ;use stack to load status
2b4a : 28              >            plp
                        
2b4b : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b4e : 08              >            php         ;save flags
2b4f : ad0302          >            lda abst
2b52 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b57 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b58 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2b5a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b5f : e8                       inx
2b60 : e002                     cpx #2
2b62 : d005                     bne tinc13
2b64 : a9fe                     lda #$fe
2b66 : 8d0302                   sta abst
2b69 : e005             tinc13   cpx #5
2b6b : d0da                     bne tinc12
2b6d : ca                       dex
2b6e : ee0302                   inc abst
2b71 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b71 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2b73 : 48              >            pha         ;use stack to load status
2b74 : 28              >            plp
                        
2b75 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b78 : 08              >            php         ;save flags
2b79 : ad0302          >            lda abst
2b7c : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2b7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b81 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b82 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2b84 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b89 : ca                       dex
2b8a : 300b                     bmi tdec13
2b8c : e001                     cpx #1
2b8e : d0e1                     bne tdec12
2b90 : a981                     lda #$81
2b92 : 8d0302                   sta abst
2b95 : d0da                     bne tdec12
2b97 :                  tdec13
                                next_test
2b97 : ad0002          >            lda test_case   ;previous test
2b9a : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b9e : a924            >            lda #test_num   ;*** next tests' number
2ba0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2ba3 : a200                     ldx #0
2ba5 : a97e                     lda #$7e
2ba7 : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2ba9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2bab : 48              >            pha         ;use stack to load status
2bac : 28              >            plp
                        
2bad : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2baf : 08              >            php         ;save flags
2bb0 : b50c            >            lda zpt,x
2bb2 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bb7 : 68              >            pla         ;load status
                       >            eor_flag 0
2bb8 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2bba : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bbf : b50c                     lda zpt,x
2bc1 : e8                       inx
2bc2 : e002                     cpx #2
2bc4 : d002                     bne tinc5
2bc6 : a9fe                     lda #$fe
2bc8 : e005             tinc5   cpx #5
2bca : d0db                     bne tinc4
2bcc : ca                       dex
2bcd : a902                     lda #2
2bcf : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2bd1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2bd3 : 48              >            pha         ;use stack to load status
2bd4 : 28              >            plp
                        
2bd5 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2bd7 : 08              >            php         ;save flags
2bd8 : b50c            >            lda zpt,x
2bda : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2bdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bdf : 68              >            pla         ;load status
                       >            eor_flag 0
2be0 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2be2 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2be5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2be7 : b50c                     lda zpt,x
2be9 : ca                       dex
2bea : 3008                     bmi tdec5
2bec : e001                     cpx #1
2bee : d0df                     bne tdec4
2bf0 : a981                     lda #$81
2bf2 : d0db                     bne tdec4
2bf4 :                  tdec5
2bf4 : a200                     ldx #0
2bf6 : a97e                     lda #$7e
2bf8 : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2bfa : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2bfc : 48              >            pha         ;use stack to load status
2bfd : 28              >            plp
                        
2bfe : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c00 : 08              >            php         ;save flags
2c01 : b50c            >            lda zpt,x
2c03 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c08 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c09 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2c0b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c10 : b50c                     lda zpt,x
2c12 : e8                       inx
2c13 : e002                     cpx #2
2c15 : d002                     bne tinc15
2c17 : a9fe                     lda #$fe
2c19 : e005             tinc15  cpx #5
2c1b : d0db                     bne tinc14
2c1d : ca                       dex
2c1e : a902                     lda #2
2c20 : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2c22 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2c24 : 48              >            pha         ;use stack to load status
2c25 : 28              >            plp
                        
2c26 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c28 : 08              >            php         ;save flags
2c29 : b50c            >            lda zpt,x
2c2b : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c30 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c31 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2c33 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c38 : b50c                     lda zpt,x
2c3a : ca                       dex
2c3b : 3008                     bmi tdec15
2c3d : e001                     cpx #1
2c3f : d0df                     bne tdec14
2c41 : a981                     lda #$81
2c43 : d0db                     bne tdec14
2c45 :                  tdec15
                                next_test
2c45 : ad0002          >            lda test_case   ;previous test
2c48 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c4c : a925            >            lda #test_num   ;*** next tests' number
2c4e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c51 : a200                     ldx #0
2c53 : a97e                     lda #$7e
2c55 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c58 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2c5a : 48              >            pha         ;use stack to load status
2c5b : 28              >            plp
                        
2c5c : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c5f : 08              >            php         ;save flags
2c60 : bd0302          >            lda abst,x
2c63 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c68 : 68              >            pla         ;load status
                       >            eor_flag 0
2c69 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2c6b : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c70 : bd0302                   lda abst,x
2c73 : e8                       inx
2c74 : e002                     cpx #2
2c76 : d002                     bne tinc7
2c78 : a9fe                     lda #$fe
2c7a : e005             tinc7   cpx #5
2c7c : d0d7                     bne tinc6
2c7e : ca                       dex
2c7f : a902                     lda #2
2c81 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c84 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2c86 : 48              >            pha         ;use stack to load status
2c87 : 28              >            plp
                        
2c88 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c8b : 08              >            php         ;save flags
2c8c : bd0302          >            lda abst,x
2c8f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2c92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c94 : 68              >            pla         ;load status
                       >            eor_flag 0
2c95 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2c97 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c9c : bd0302                   lda abst,x
2c9f : ca                       dex
2ca0 : 3008                     bmi tdec7
2ca2 : e001                     cpx #1
2ca4 : d0db                     bne tdec6
2ca6 : a981                     lda #$81
2ca8 : d0d7                     bne tdec6
2caa :                  tdec7
2caa : a200                     ldx #0
2cac : a97e                     lda #$7e
2cae : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2cb1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2cb3 : 48              >            pha         ;use stack to load status
2cb4 : 28              >            plp
                        
2cb5 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2cb8 : 08              >            php         ;save flags
2cb9 : bd0302          >            lda abst,x
2cbc : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2cbf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cc1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cc2 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2cc4 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cc9 : bd0302                   lda abst,x
2ccc : e8                       inx
2ccd : e002                     cpx #2
2ccf : d002                     bne tinc17
2cd1 : a9fe                     lda #$fe
2cd3 : e005             tinc17  cpx #5
2cd5 : d0d7                     bne tinc16
2cd7 : ca                       dex
2cd8 : a902                     lda #2
2cda : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2cdd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2cdf : 48              >            pha         ;use stack to load status
2ce0 : 28              >            plp
                        
2ce1 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ce4 : 08              >            php         ;save flags
2ce5 : bd0302          >            lda abst,x
2ce8 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ceb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ced : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cee : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2cf0 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cf3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cf5 : bd0302                   lda abst,x
2cf8 : ca                       dex
2cf9 : 3008                     bmi tdec17
2cfb : e001                     cpx #1
2cfd : d0db                     bne tdec16
2cff : a981                     lda #$81
2d01 : d0d7                     bne tdec16
2d03 :                  tdec17
                                next_test
2d03 : ad0002          >            lda test_case   ;previous test
2d06 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2d08 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2d0a : a926            >            lda #test_num   ;*** next tests' number
2d0c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2d0f : a203                     ldx #3          ;immediate
2d11 : b51e             tand    lda zpAN,x
2d13 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2d16 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2d18 : 48              >            pha         ;use stack to load status
2d19 : bd6b02          >            lda absANa,x    ;precharge accu
2d1c : 28              >            plp
                        
2d1d : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2d20 : 08              >            php         ;save flags
2d21 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d26 : 68              >            pla         ;load status
                       >            eor_flag 0
2d27 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2d29 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d2e : ca                       dex
2d2f : 10e0                     bpl tand
2d31 : a203                     ldx #3
2d33 : b51e             tand1   lda zpAN,x
2d35 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d38 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2d3a : 48              >            pha         ;use stack to load status
2d3b : bd6b02          >            lda absANa,x    ;precharge accu
2d3e : 28              >            plp
                        
2d3f : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d42 : 08              >            php         ;save flags
2d43 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d48 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d49 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2d4b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d50 : ca                       dex
2d51 : 10e0                     bpl tand1
                            
2d53 : a203                     ldx #3      ;zp
2d55 : b51e             tand2   lda zpAN,x
2d57 : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d59 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2d5b : 48              >            pha         ;use stack to load status
2d5c : bd6b02          >            lda absANa,x    ;precharge accu
2d5f : 28              >            plp
                        
2d60 : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
2d62 : 08              >            php         ;save flags
2d63 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d68 : 68              >            pla         ;load status
                       >            eor_flag 0
2d69 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2d6b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d70 : ca                       dex
2d71 : 10e2                     bpl tand2
2d73 : a203                     ldx #3
2d75 : b51e             tand3   lda zpAN,x
2d77 : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d79 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2d7b : 48              >            pha         ;use stack to load status
2d7c : bd6b02          >            lda absANa,x    ;precharge accu
2d7f : 28              >            plp
                        
2d80 : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d82 : 08              >            php         ;save flags
2d83 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d88 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d89 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2d8b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d90 : ca                       dex
2d91 : 10e2                     bpl tand3
                        
2d93 : a203                     ldx #3      ;abs
2d95 : b51e             tand4   lda zpAN,x
2d97 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d9a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2d9c : 48              >            pha         ;use stack to load status
2d9d : bd6b02          >            lda absANa,x    ;precharge accu
2da0 : 28              >            plp
                        
2da1 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2da4 : 08              >            php         ;save flags
2da5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2da8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2daa : 68              >            pla         ;load status
                       >            eor_flag 0
2dab : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2dad : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2db0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2db2 : ca                       dex
2db3 : 10e0                     bpl tand4
2db5 : a203                     ldx #3
2db7 : b51e             tand5   lda zpAN,x
2db9 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dbc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2dbe : 48              >            pha         ;use stack to load status
2dbf : bd6b02          >            lda absANa,x    ;precharge accu
2dc2 : 28              >            plp
                        
2dc3 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2dc6 : 08              >            php         ;save flags
2dc7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dcc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dcd : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2dcf : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dd4 : ca                       dex
2dd5 : 1002                     bpl tand6
                        
2dd7 : a203                     ldx #3      ;zp,x
2dd9 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2dd9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2ddb : 48              >            pha         ;use stack to load status
2ddc : bd6b02          >            lda absANa,x    ;precharge accu
2ddf : 28              >            plp
                        
2de0 : 351e                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2de2 : 08              >            php         ;save flags
2de3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2de6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2de8 : 68              >            pla         ;load status
                       >            eor_flag 0
2de9 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2deb : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2df0 : ca                       dex
2df1 : 10e6                     bpl tand6
2df3 : a203                     ldx #3
2df5 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2df5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2df7 : 48              >            pha         ;use stack to load status
2df8 : bd6b02          >            lda absANa,x    ;precharge accu
2dfb : 28              >            plp
                        
2dfc : 351e                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2dfe : 08              >            php         ;save flags
2dff : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e05 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e07 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e0c : ca                       dex
2e0d : 10e6                     bpl tand7
                        
2e0f : a203                     ldx #3      ;abs,x
2e11 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2e11 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2e13 : 48              >            pha         ;use stack to load status
2e14 : bd6b02          >            lda absANa,x    ;precharge accu
2e17 : 28              >            plp
                        
2e18 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2e1b : 08              >            php         ;save flags
2e1c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e21 : 68              >            pla         ;load status
                       >            eor_flag 0
2e22 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e24 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e29 : ca                       dex
2e2a : 10e5                     bpl tand8
2e2c : a203                     ldx #3
2e2e :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e2e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2e30 : 48              >            pha         ;use stack to load status
2e31 : bd6b02          >            lda absANa,x    ;precharge accu
2e34 : 28              >            plp
                        
2e35 : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e38 : 08              >            php         ;save flags
2e39 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e3e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e3f : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e41 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e46 : ca                       dex
2e47 : 10e5                     bpl tand9
                        
2e49 : a003                     ldy #3      ;abs,y
2e4b :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e4b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2e4d : 48              >            pha         ;use stack to load status
2e4e : b96b02          >            lda absANa,y    ;precharge accu
2e51 : 28              >            plp
                        
2e52 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e55 : 08              >            php         ;save flags
2e56 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e5b : 68              >            pla         ;load status
                       >            eor_flag 0
2e5c : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e5e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e63 : 88                       dey
2e64 : 10e5                     bpl tand10
2e66 : a003                     ldy #3
2e68 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e68 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2e6a : 48              >            pha         ;use stack to load status
2e6b : b96b02          >            lda absANa,y    ;precharge accu
2e6e : 28              >            plp
                        
2e6f : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e72 : 08              >            php         ;save flags
2e73 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e78 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e79 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e7b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e80 : 88                       dey
2e81 : 10e5                     bpl tand11
                        
2e83 : a206                     ldx #6      ;(zp,x)
2e85 : a003                     ldy #3
2e87 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e87 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2e89 : 48              >            pha         ;use stack to load status
2e8a : b96b02          >            lda absANa,y    ;precharge accu
2e8d : 28              >            plp
                        
2e8e : 213c                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e90 : 08              >            php         ;save flags
2e91 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e96 : 68              >            pla         ;load status
                       >            eor_flag 0
2e97 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2e99 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e9e : ca                       dex
2e9f : ca                       dex
2ea0 : 88                       dey
2ea1 : 10e4                     bpl tand12
2ea3 : a206                     ldx #6
2ea5 : a003                     ldy #3
2ea7 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ea7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2ea9 : 48              >            pha         ;use stack to load status
2eaa : b96b02          >            lda absANa,y    ;precharge accu
2ead : 28              >            plp
                        
2eae : 213c                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2eb0 : 08              >            php         ;save flags
2eb1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2eb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eb6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eb7 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2eb9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ebc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ebe : ca                       dex
2ebf : ca                       dex
2ec0 : 88                       dey
2ec1 : 10e4                     bpl tand13
                        
2ec3 : a003                     ldy #3      ;(zp),y
2ec5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2ec5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2ec7 : 48              >            pha         ;use stack to load status
2ec8 : b96b02          >            lda absANa,y    ;precharge accu
2ecb : 28              >            plp
                        
2ecc : 313c                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2ece : 08              >            php         ;save flags
2ecf : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ed2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ed4 : 68              >            pla         ;load status
                       >            eor_flag 0
2ed5 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2ed7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2edc : 88                       dey
2edd : 10e6                     bpl tand14
2edf : a003                     ldy #3
2ee1 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ee1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2ee3 : 48              >            pha         ;use stack to load status
2ee4 : b96b02          >            lda absANa,y    ;precharge accu
2ee7 : 28              >            plp
                        
2ee8 : 313c                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2eea : 08              >            php         ;save flags
2eeb : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2eee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ef0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ef1 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2ef3 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ef6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ef8 : 88                       dey
2ef9 : 10e6                     bpl tand15
                                next_test
2efb : ad0002          >            lda test_case   ;previous test
2efe : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2f00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2f02 : a927            >            lda #test_num   ;*** next tests' number
2f04 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2f07 : a203                     ldx #3          ;immediate - self modifying code
2f09 : b522             teor    lda zpEO,x
2f0b : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2f0e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2f10 : 48              >            pha         ;use stack to load status
2f11 : bd6f02          >            lda absEOa,x    ;precharge accu
2f14 : 28              >            plp
                        
2f15 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2f18 : 08              >            php         ;save flags
2f19 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f1e : 68              >            pla         ;load status
                       >            eor_flag 0
2f1f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2f21 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f26 : ca                       dex
2f27 : 10e0                     bpl teor
2f29 : a203                     ldx #3
2f2b : b522             teor1   lda zpEO,x
2f2d : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f30 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2f32 : 48              >            pha         ;use stack to load status
2f33 : bd6f02          >            lda absEOa,x    ;precharge accu
2f36 : 28              >            plp
                        
2f37 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2f3a : 08              >            php         ;save flags
2f3b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f40 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f41 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2f43 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f48 : ca                       dex
2f49 : 10e0                     bpl teor1
                            
2f4b : a203                     ldx #3      ;zp
2f4d : b522             teor2    lda zpEO,x
2f4f : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f51 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2f53 : 48              >            pha         ;use stack to load status
2f54 : bd6f02          >            lda absEOa,x    ;precharge accu
2f57 : 28              >            plp
                        
2f58 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
2f5a : 08              >            php         ;save flags
2f5b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f60 : 68              >            pla         ;load status
                       >            eor_flag 0
2f61 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2f63 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f68 : ca                       dex
2f69 : 10e2                     bpl teor2
2f6b : a203                     ldx #3
2f6d : b522             teor3   lda zpEO,x
2f6f : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f71 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2f73 : 48              >            pha         ;use stack to load status
2f74 : bd6f02          >            lda absEOa,x    ;precharge accu
2f77 : 28              >            plp
                        
2f78 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f7a : 08              >            php         ;save flags
2f7b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f80 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f81 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2f83 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f88 : ca                       dex
2f89 : 10e2                     bpl teor3
                        
2f8b : a203                     ldx #3      ;abs
2f8d : b522             teor4   lda zpEO,x
2f8f : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f92 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2f94 : 48              >            pha         ;use stack to load status
2f95 : bd6f02          >            lda absEOa,x    ;precharge accu
2f98 : 28              >            plp
                        
2f99 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f9c : 08              >            php         ;save flags
2f9d : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fa0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fa2 : 68              >            pla         ;load status
                       >            eor_flag 0
2fa3 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2fa5 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2faa : ca                       dex
2fab : 10e0                     bpl teor4
2fad : a203                     ldx #3
2faf : b522             teor5   lda zpEO,x
2fb1 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fb4 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2fb6 : 48              >            pha         ;use stack to load status
2fb7 : bd6f02          >            lda absEOa,x    ;precharge accu
2fba : 28              >            plp
                        
2fbb : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2fbe : 08              >            php         ;save flags
2fbf : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fc4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fc5 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2fc7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fcc : ca                       dex
2fcd : 1002                     bpl teor6
                        
2fcf : a203                     ldx #3      ;zp,x
2fd1 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2fd1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2fd3 : 48              >            pha         ;use stack to load status
2fd4 : bd6f02          >            lda absEOa,x    ;precharge accu
2fd7 : 28              >            plp
                        
2fd8 : 5522                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2fda : 08              >            php         ;save flags
2fdb : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fde : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fe0 : 68              >            pla         ;load status
                       >            eor_flag 0
2fe1 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2fe3 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fe6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fe8 : ca                       dex
2fe9 : 10e6                     bpl teor6
2feb : a203                     ldx #3
2fed :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fed : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2fef : 48              >            pha         ;use stack to load status
2ff0 : bd6f02          >            lda absEOa,x    ;precharge accu
2ff3 : 28              >            plp
                        
2ff4 : 5522                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2ff6 : 08              >            php         ;save flags
2ff7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ffa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ffc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ffd : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
2fff : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3002 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3004 : ca                       dex
3005 : 10e6                     bpl teor7
                        
3007 : a203                     ldx #3      ;abs,x
3009 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
3009 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
300b : 48              >            pha         ;use stack to load status
300c : bd6f02          >            lda absEOa,x    ;precharge accu
300f : 28              >            plp
                        
3010 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3013 : 08              >            php         ;save flags
3014 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3017 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3019 : 68              >            pla         ;load status
                       >            eor_flag 0
301a : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
301c : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
301f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3021 : ca                       dex
3022 : 10e5                     bpl teor8
3024 : a203                     ldx #3
3026 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3026 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3028 : 48              >            pha         ;use stack to load status
3029 : bd6f02          >            lda absEOa,x    ;precharge accu
302c : 28              >            plp
                        
302d : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3030 : 08              >            php         ;save flags
3031 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3034 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3036 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3037 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3039 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
303c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
303e : ca                       dex
303f : 10e5                     bpl teor9
                        
3041 : a003                     ldy #3      ;abs,y
3043 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3043 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3045 : 48              >            pha         ;use stack to load status
3046 : b96f02          >            lda absEOa,y    ;precharge accu
3049 : 28              >            plp
                        
304a : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
304d : 08              >            php         ;save flags
304e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3051 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3053 : 68              >            pla         ;load status
                       >            eor_flag 0
3054 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3056 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3059 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
305b : 88                       dey
305c : 10e5                     bpl teor10
305e : a003                     ldy #3
3060 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3060 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3062 : 48              >            pha         ;use stack to load status
3063 : b96f02          >            lda absEOa,y    ;precharge accu
3066 : 28              >            plp
                        
3067 : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
306a : 08              >            php         ;save flags
306b : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
306e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3070 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3071 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3073 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3076 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3078 : 88                       dey
3079 : 10e5                     bpl teor11
                        
307b : a206                     ldx #6      ;(zp,x)
307d : a003                     ldy #3
307f :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
307f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3081 : 48              >            pha         ;use stack to load status
3082 : b96f02          >            lda absEOa,y    ;precharge accu
3085 : 28              >            plp
                        
3086 : 4144                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3088 : 08              >            php         ;save flags
3089 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
308c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
308e : 68              >            pla         ;load status
                       >            eor_flag 0
308f : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3091 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3094 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3096 : ca                       dex
3097 : ca                       dex
3098 : 88                       dey
3099 : 10e4                     bpl teor12
309b : a206                     ldx #6
309d : a003                     ldy #3
309f :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
309f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
30a1 : 48              >            pha         ;use stack to load status
30a2 : b96f02          >            lda absEOa,y    ;precharge accu
30a5 : 28              >            plp
                        
30a6 : 4144                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
30a8 : 08              >            php         ;save flags
30a9 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30ae : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30af : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
30b1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
30b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30b6 : ca                       dex
30b7 : ca                       dex
30b8 : 88                       dey
30b9 : 10e4                     bpl teor13
                        
30bb : a003                     ldy #3      ;(zp),y
30bd :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
30bd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
30bf : 48              >            pha         ;use stack to load status
30c0 : b96f02          >            lda absEOa,y    ;precharge accu
30c3 : 28              >            plp
                        
30c4 : 5144                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
30c6 : 08              >            php         ;save flags
30c7 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30cc : 68              >            pla         ;load status
                       >            eor_flag 0
30cd : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
30cf : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
30d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30d4 : 88                       dey
30d5 : 10e6                     bpl teor14
30d7 : a003                     ldy #3
30d9 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30d9 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
30db : 48              >            pha         ;use stack to load status
30dc : b96f02          >            lda absEOa,y    ;precharge accu
30df : 28              >            plp
                        
30e0 : 5144                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
30e2 : 08              >            php         ;save flags
30e3 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30e8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30e9 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
30eb : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
30ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30f0 : 88                       dey
30f1 : 10e6                     bpl teor15
                                next_test
30f3 : ad0002          >            lda test_case   ;previous test
30f6 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
30f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
30fa : a928            >            lda #test_num   ;*** next tests' number
30fc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
30ff : a203                     ldx #3          ;immediate - self modifying code
3101 : b51a             tora    lda zpOR,x
3103 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
3106 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3108 : 48              >            pha         ;use stack to load status
3109 : bd6702          >            lda absORa,x    ;precharge accu
310c : 28              >            plp
                        
310d : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3110 : 08              >            php         ;save flags
3111 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3114 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3116 : 68              >            pla         ;load status
                       >            eor_flag 0
3117 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3119 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
311c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
311e : ca                       dex
311f : 10e0                     bpl tora
3121 : a203                     ldx #3
3123 : b51a             tora1   lda zpOR,x
3125 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
3128 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
312a : 48              >            pha         ;use stack to load status
312b : bd6702          >            lda absORa,x    ;precharge accu
312e : 28              >            plp
                        
312f : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3132 : 08              >            php         ;save flags
3133 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3136 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3138 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3139 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
313b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
313e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3140 : ca                       dex
3141 : 10e0                     bpl tora1
                            
3143 : a203                     ldx #3      ;zp
3145 : b51a             tora2   lda zpOR,x
3147 : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3149 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
314b : 48              >            pha         ;use stack to load status
314c : bd6702          >            lda absORa,x    ;precharge accu
314f : 28              >            plp
                        
3150 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
3152 : 08              >            php         ;save flags
3153 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3156 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3158 : 68              >            pla         ;load status
                       >            eor_flag 0
3159 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
315b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
315e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3160 : ca                       dex
3161 : 10e2                     bpl tora2
3163 : a203                     ldx #3
3165 : b51a             tora3   lda zpOR,x
3167 : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3169 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
316b : 48              >            pha         ;use stack to load status
316c : bd6702          >            lda absORa,x    ;precharge accu
316f : 28              >            plp
                        
3170 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3172 : 08              >            php         ;save flags
3173 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3176 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3178 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3179 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
317b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
317e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3180 : ca                       dex
3181 : 10e2                     bpl tora3
                        
3183 : a203                     ldx #3      ;abs
3185 : b51a             tora4   lda zpOR,x
3187 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
318a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
318c : 48              >            pha         ;use stack to load status
318d : bd6702          >            lda absORa,x    ;precharge accu
3190 : 28              >            plp
                        
3191 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
3194 : 08              >            php         ;save flags
3195 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3198 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
319a : 68              >            pla         ;load status
                       >            eor_flag 0
319b : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
319d : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31a2 : ca                       dex
31a3 : 10e0                     bpl tora4
31a5 : a203                     ldx #3
31a7 : b51a             tora5   lda zpOR,x
31a9 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
31ac : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
31ae : 48              >            pha         ;use stack to load status
31af : bd6702          >            lda absORa,x    ;precharge accu
31b2 : 28              >            plp
                        
31b3 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
31b6 : 08              >            php         ;save flags
31b7 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31bc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31bd : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
31bf : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31c4 : ca                       dex
31c5 : 1002                     bpl tora6
                        
31c7 : a203                     ldx #3      ;zp,x
31c9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
31c9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
31cb : 48              >            pha         ;use stack to load status
31cc : bd6702          >            lda absORa,x    ;precharge accu
31cf : 28              >            plp
                        
31d0 : 151a                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
31d2 : 08              >            php         ;save flags
31d3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31d8 : 68              >            pla         ;load status
                       >            eor_flag 0
31d9 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
31db : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31e0 : ca                       dex
31e1 : 10e6                     bpl tora6
31e3 : a203                     ldx #3
31e5 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
31e5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
31e7 : 48              >            pha         ;use stack to load status
31e8 : bd6702          >            lda absORa,x    ;precharge accu
31eb : 28              >            plp
                        
31ec : 151a                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31ee : 08              >            php         ;save flags
31ef : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
31f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31f5 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
31f7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31fc : ca                       dex
31fd : 10e6                     bpl tora7
                        
31ff : a203                     ldx #3      ;abs,x
3201 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3201 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3203 : 48              >            pha         ;use stack to load status
3204 : bd6702          >            lda absORa,x    ;precharge accu
3207 : 28              >            plp
                        
3208 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
320b : 08              >            php         ;save flags
320c : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
320f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3211 : 68              >            pla         ;load status
                       >            eor_flag 0
3212 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3214 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3217 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3219 : ca                       dex
321a : 10e5                     bpl tora8
321c : a203                     ldx #3
321e :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
321e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3220 : 48              >            pha         ;use stack to load status
3221 : bd6702          >            lda absORa,x    ;precharge accu
3224 : 28              >            plp
                        
3225 : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3228 : 08              >            php         ;save flags
3229 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
322c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
322e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
322f : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3231 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3234 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3236 : ca                       dex
3237 : 10e5                     bpl tora9
                        
3239 : a003                     ldy #3      ;abs,y
323b :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
323b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
323d : 48              >            pha         ;use stack to load status
323e : b96702          >            lda absORa,y    ;precharge accu
3241 : 28              >            plp
                        
3242 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3245 : 08              >            php         ;save flags
3246 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3249 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
324b : 68              >            pla         ;load status
                       >            eor_flag 0
324c : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
324e : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3251 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3253 : 88                       dey
3254 : 10e5                     bpl tora10
3256 : a003                     ldy #3
3258 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3258 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
325a : 48              >            pha         ;use stack to load status
325b : b96702          >            lda absORa,y    ;precharge accu
325e : 28              >            plp
                        
325f : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3262 : 08              >            php         ;save flags
3263 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3266 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3268 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3269 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
326b : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
326e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3270 : 88                       dey
3271 : 10e5                     bpl tora11
                        
3273 : a206                     ldx #6      ;(zp,x)
3275 : a003                     ldy #3
3277 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
3277 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3279 : 48              >            pha         ;use stack to load status
327a : b96702          >            lda absORa,y    ;precharge accu
327d : 28              >            plp
                        
327e : 014c                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
3280 : 08              >            php         ;save flags
3281 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3284 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3286 : 68              >            pla         ;load status
                       >            eor_flag 0
3287 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
3289 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
328c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
328e : ca                       dex
328f : ca                       dex
3290 : 88                       dey
3291 : 10e4                     bpl tora12
3293 : a206                     ldx #6
3295 : a003                     ldy #3
3297 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
3297 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3299 : 48              >            pha         ;use stack to load status
329a : b96702          >            lda absORa,y    ;precharge accu
329d : 28              >            plp
                        
329e : 014c                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
32a0 : 08              >            php         ;save flags
32a1 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32a6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32a7 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
32a9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
32ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32ae : ca                       dex
32af : ca                       dex
32b0 : 88                       dey
32b1 : 10e4                     bpl tora13
                        
32b3 : a003                     ldy #3      ;(zp),y
32b5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
32b5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
32b7 : 48              >            pha         ;use stack to load status
32b8 : b96702          >            lda absORa,y    ;precharge accu
32bb : 28              >            plp
                        
32bc : 114c                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
32be : 08              >            php         ;save flags
32bf : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32c4 : 68              >            pla         ;load status
                       >            eor_flag 0
32c5 : 4930            >            eor #(0&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
32c7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
32ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32cc : 88                       dey
32cd : 10e6                     bpl tora14
32cf : a003                     ldy #3
32d1 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
32d1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
32d3 : 48              >            pha         ;use stack to load status
32d4 : b96702          >            lda absORa,y    ;precharge accu
32d7 : 28              >            plp
                        
32d8 : 114c                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
32da : 08              >            php         ;save flags
32db : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32e0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32e1 : 4979            >            eor #($ff-fnz&m8i|fao)   ;mask I, invert expected flags + always on bits
                       >
32e3 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
32e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32e8 : 88                       dey
32e9 : 10e6                     bpl tora15
                            if I_flag = 3
                                cli
                            endif                
                                next_test
32eb : ad0002          >            lda test_case   ;previous test
32ee : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
32f2 : a929            >            lda #test_num   ;*** next tests' number
32f4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
32f7 : d8                       cld
32f8 : a20e                     ldx #ad2        ;for indexed test
32fa : a0ff                     ldy #$ff        ;max range
32fc : a900                     lda #0          ;start with adding zeroes & no carry
32fe : 850c                     sta adfc        ;carry in - for diag
3300 : 850d                     sta ad1         ;operand 1 - accumulator
3302 : 850e                     sta ad2         ;operand 2 - memory or immediate
3304 : 8d0302                   sta ada2        ;non zp
3307 : 850f                     sta adrl        ;expected result bits 0-7
3309 : 8510                     sta adrh        ;expected result bit 8 (carry out)
330b : a9ff                     lda #$ff        ;complemented operand 2 for subtract
330d : 8512                     sta sb2
330f : 8d0402                   sta sba2        ;non zp
3312 : a902                     lda #2          ;expected Z-flag
3314 : 8511                     sta adrf
3316 : 18               tadd    clc             ;test with carry clear
3317 : 206233                   jsr chkadd
331a : e60c                     inc adfc        ;now with carry
331c : e60f                     inc adrl        ;result +1
331e : 08                       php             ;save N & Z from low result
331f : 08                       php
3320 : 68                       pla             ;accu holds expected flags
3321 : 2982                     and #$82        ;mask N & Z
3323 : 28                       plp
3324 : d002                     bne tadd1
3326 : e610                     inc adrh        ;result bit 8 - carry
3328 : 0510             tadd1   ora adrh        ;merge C to expected flags
332a : 8511                     sta adrf        ;save expected flags except overflow
332c : 38                       sec             ;test with carry set
332d : 206233                   jsr chkadd
3330 : c60c                     dec adfc        ;same for operand +1 but no carry
3332 : e60d                     inc ad1
3334 : d0e0                     bne tadd        ;iterate op1
3336 : a900                     lda #0          ;preset result to op2 when op1 = 0
3338 : 8510                     sta adrh
333a : ee0302                   inc ada2
333d : e60e                     inc ad2
333f : 08                       php             ;save NZ as operand 2 becomes the new result
3340 : 68                       pla
3341 : 2982                     and #$82        ;mask N00000Z0
3343 : 8511                     sta adrf        ;no need to check carry as we are adding to 0
3345 : c612                     dec sb2         ;complement subtract operand 2
3347 : ce0402                   dec sba2
334a : a50e                     lda ad2         
334c : 850f                     sta adrl
334e : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3350 : ad0002                   lda test_case
3353 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3355 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3357 : a9f0                     lda #$f0        ;mark opcode testing complete
3359 : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
335c : 4c5c33          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
335f : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3362 : a511             chkadd  lda adrf        ;add V-flag if overflow
3364 : 2983                     and #$83        ;keep N-----ZC / clear V
3366 : 48                       pha
3367 : a50d                     lda ad1         ;test sign unequal between operands
3369 : 450e                     eor ad2
336b : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
336d : a50d                     lda ad1         ;test sign equal between operands and result
336f : 450f                     eor adrl
3371 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3373 : 68                       pla
3374 : 0940                     ora #$40        ;set V
3376 : 48                       pha
3377 : 68               ckad1   pla
3378 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
337a : 08                       php             ;save carry for subtract
337b : a50d                     lda ad1
337d : 650e                     adc ad2         ;perform add
337f : 08                       php          
3380 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3382 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3384 : 68                       pla             ;check flags
3385 : 29c3                     and #$c3        ;mask NV----ZC
3387 : c511                     cmp adrf
                                trap_ne         ;bad flags
3389 : d0fe            >        bne *           ;failed not equal (non zero)
                        
338b : 28                       plp
338c : 08                       php             ;save carry for next add
338d : a50d                     lda ad1
338f : e512                     sbc sb2         ;perform subtract
3391 : 08                       php          
3392 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3394 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3396 : 68                       pla             ;check flags
3397 : 29c3                     and #$c3        ;mask NV----ZC
3399 : c511                     cmp adrf
                                trap_ne         ;bad flags
339b : d0fe            >        bne *           ;failed not equal (non zero)
                        
339d : 28                       plp
                        ; binary ADC / SBC abs
339e : 08                       php             ;save carry for subtract
339f : a50d                     lda ad1
33a1 : 6d0302                   adc ada2        ;perform add
33a4 : 08                       php          
33a5 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33a9 : 68                       pla             ;check flags
33aa : 29c3                     and #$c3        ;mask NV----ZC
33ac : c511                     cmp adrf
                                trap_ne         ;bad flags
33ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b0 : 28                       plp
33b1 : 08                       php             ;save carry for next add
33b2 : a50d                     lda ad1
33b4 : ed0402                   sbc sba2        ;perform subtract
33b7 : 08                       php          
33b8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
33bc : 68                       pla             ;check flags
33bd : 29c3                     and #$c3        ;mask NV----ZC
33bf : c511                     cmp adrf
                                trap_ne         ;bad flags
33c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33c3 : 28                       plp
                        ; binary ADC / SBC #
33c4 : 08                       php             ;save carry for subtract
33c5 : a50e                     lda ad2
33c7 : 8d1302                   sta ex_adci+1   ;set ADC # operand
33ca : a50d                     lda ad1
33cc : 201202                   jsr ex_adci     ;execute ADC # in RAM
33cf : 08                       php          
33d0 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33d4 : 68                       pla             ;check flags
33d5 : 29c3                     and #$c3        ;mask NV----ZC
33d7 : c511                     cmp adrf
                                trap_ne         ;bad flags
33d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33db : 28                       plp
33dc : 08                       php             ;save carry for next add
33dd : a512                     lda sb2
33df : 8d1602                   sta ex_sbci+1   ;set SBC # operand
33e2 : a50d                     lda ad1
33e4 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
33e7 : 08                       php          
33e8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ec : 68                       pla             ;check flags
33ed : 29c3                     and #$c3        ;mask NV----ZC
33ef : c511                     cmp adrf
                                trap_ne         ;bad flags
33f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f3 : 28                       plp
                        ; binary ADC / SBC zp,x
33f4 : 08                       php             ;save carry for subtract
33f5 : a50d                     lda ad1
33f7 : 7500                     adc 0,x         ;perform add
33f9 : 08                       php          
33fa : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
33fe : 68                       pla             ;check flags
33ff : 29c3                     and #$c3        ;mask NV----ZC
3401 : c511                     cmp adrf
                                trap_ne         ;bad flags
3403 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3405 : 28                       plp
3406 : 08                       php             ;save carry for next add
3407 : a50d                     lda ad1
3409 : f504                     sbc sb2-ad2,x   ;perform subtract
340b : 08                       php          
340c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
340e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3410 : 68                       pla             ;check flags
3411 : 29c3                     and #$c3        ;mask NV----ZC
3413 : c511                     cmp adrf
                                trap_ne         ;bad flags
3415 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3417 : 28                       plp
                        ; binary ADC / SBC abs,x
3418 : 08                       php             ;save carry for subtract
3419 : a50d                     lda ad1
341b : 7df501                   adc ada2-ad2,x  ;perform add
341e : 08                       php          
341f : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3421 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3423 : 68                       pla             ;check flags
3424 : 29c3                     and #$c3        ;mask NV----ZC
3426 : c511                     cmp adrf
                                trap_ne         ;bad flags
3428 : d0fe            >        bne *           ;failed not equal (non zero)
                        
342a : 28                       plp
342b : 08                       php             ;save carry for next add
342c : a50d                     lda ad1
342e : fdf601                   sbc sba2-ad2,x  ;perform subtract
3431 : 08                       php          
3432 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3434 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3436 : 68                       pla             ;check flags
3437 : 29c3                     and #$c3        ;mask NV----ZC
3439 : c511                     cmp adrf
                                trap_ne         ;bad flags
343b : d0fe            >        bne *           ;failed not equal (non zero)
                        
343d : 28                       plp
                        ; binary ADC / SBC abs,y
343e : 08                       php             ;save carry for subtract
343f : a50d                     lda ad1
3441 : 790401                   adc ada2-$ff,y  ;perform add
3444 : 08                       php          
3445 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3447 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3449 : 68                       pla             ;check flags
344a : 29c3                     and #$c3        ;mask NV----ZC
344c : c511                     cmp adrf
                                trap_ne         ;bad flags
344e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3450 : 28                       plp
3451 : 08                       php             ;save carry for next add
3452 : a50d                     lda ad1
3454 : f90501                   sbc sba2-$ff,y  ;perform subtract
3457 : 08                       php          
3458 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
345a : d0fe            >        bne *           ;failed not equal (non zero)
                        
345c : 68                       pla             ;check flags
345d : 29c3                     and #$c3        ;mask NV----ZC
345f : c511                     cmp adrf
                                trap_ne         ;bad flags
3461 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3463 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3464 : 08                       php             ;save carry for subtract
3465 : a50d                     lda ad1
3467 : 6146                     adc (lo adi2-ad2,x) ;perform add
3469 : 08                       php          
346a : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
346c : d0fe            >        bne *           ;failed not equal (non zero)
                        
346e : 68                       pla             ;check flags
346f : 29c3                     and #$c3        ;mask NV----ZC
3471 : c511                     cmp adrf
                                trap_ne         ;bad flags
3473 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3475 : 28                       plp
3476 : 08                       php             ;save carry for next add
3477 : a50d                     lda ad1
3479 : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
347b : 08                       php          
347c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
347e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3480 : 68                       pla             ;check flags
3481 : 29c3                     and #$c3        ;mask NV----ZC
3483 : c511                     cmp adrf
                                trap_ne         ;bad flags
3485 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3487 : 28                       plp
                        ; binary ADC / SBC (abs),y
3488 : 08                       php             ;save carry for subtract
3489 : a50d                     lda ad1
348b : 7158                     adc (adiy2),y   ;perform add
348d : 08                       php          
348e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3490 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3492 : 68                       pla             ;check flags
3493 : 29c3                     and #$c3        ;mask NV----ZC
3495 : c511                     cmp adrf
                                trap_ne         ;bad flags
3497 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3499 : 28                       plp
349a : 08                       php             ;save carry for next add
349b : a50d                     lda ad1
349d : f15a                     sbc (sbiy2),y   ;perform subtract
349f : 08                       php          
34a0 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a4 : 68                       pla             ;check flags
34a5 : 29c3                     and #$c3        ;mask NV----ZC
34a7 : c511                     cmp adrf
                                trap_ne         ;bad flags
34a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ab : 28                       plp
34ac : 60                       rts
                        
                        ; target for the jump absolute test
34ad : 88                       dey
34ae : 88                       dey
34af :                  test_far
34af : 08                       php             ;either SP or Y count will fail, if we do not hit
34b0 : 88                       dey
34b1 : 88                       dey
34b2 : 88                       dey
34b3 : 28                       plp
                                trap_cs         ;flags loaded?
34b4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
34b6 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
34b8 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
34ba : f0fe            >        beq *           ;failed equal (zero)
                        
34bc : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
34be : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c0 : e041                     cpx #'A'
                                trap_ne        
34c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c4 : c04f                     cpy #('R'-3)
                                trap_ne
34c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c8 : 48                       pha             ;save a,x
34c9 : 8a                       txa
34ca : 48                       pha
34cb : ba                       tsx
34cc : e0fd                     cpx #$fd        ;check SP
                                trap_ne
34ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d0 : 68                       pla             ;restore x
34d1 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
34d2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
34d4 : 48              >            pha         ;use stack to load status
34d5 : 28              >            plp
                        
34d6 : 68                       pla             ;restore a
34d7 : e8                       inx             ;return registers with modifications
34d8 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
34da : 4c0f09                   jmp far_ret
                                
                        ; target for the jump indirect test
34dd : 00                       align
34de : e734             ptr_tst_ind dw test_ind
34e0 : 6409             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
34e2 : 4ce234          >        jmp *           ;failed anyway
                        
34e5 : 88                       dey
34e6 : 88                       dey
34e7 :                  test_ind
34e7 : 08                       php             ;either SP or Y count will fail, if we do not hit
34e8 : 88                       dey
34e9 : 88                       dey
34ea : 88                       dey
34eb : 28                       plp
                                trap_cs         ;flags loaded?
34ec : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
34ee : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
34f0 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
34f2 : f0fe            >        beq *           ;failed equal (zero)
                        
34f4 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
34f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f8 : e04e                     cpx #'N'
                                trap_ne        
34fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
34fc : c041                     cpy #('D'-3)
                                trap_ne
34fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
3500 : 48                       pha             ;save a,x
3501 : 8a                       txa
3502 : 48                       pha
3503 : ba                       tsx
3504 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3506 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3508 : 68                       pla             ;restore x
3509 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
350a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
350c : 48              >            pha         ;use stack to load status
350d : 28              >            plp
                        
350e : 68                       pla             ;restore a
350f : e8                       inx             ;return registers with modifications
3510 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3512 : 6ce034                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3515 : 4c1535          >        jmp *           ;failed anyway
                        
3518 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
351b : 88                       dey
351c : 88                       dey
351d :                  test_jsr
351d : 08                       php             ;either SP or Y count will fail, if we do not hit
351e : 88                       dey
351f : 88                       dey
3520 : 88                       dey
3521 : 28                       plp
                                trap_cs         ;flags loaded?
3522 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3524 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3526 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3528 : f0fe            >        beq *           ;failed equal (zero)
                        
352a : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
352c : d0fe            >        bne *           ;failed not equal (non zero)
                        
352e : e053                     cpx #'S'
                                trap_ne        
3530 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3532 : c04f                     cpy #('R'-3)
                                trap_ne
3534 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3536 : 48                       pha             ;save a,x
3537 : 8a                       txa
3538 : 48                       pha       
3539 : ba                       tsx             ;sp -4? (return addr,a,x)
353a : e0fb                     cpx #$fb
                                trap_ne
353c : d0fe            >        bne *           ;failed not equal (non zero)
                        
353e : adff01                   lda $1ff        ;propper return on stack
3541 : c909                     cmp #hi(jsr_ret)
                                trap_ne
3543 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3545 : adfe01                   lda $1fe
3548 : c99a                     cmp #lo(jsr_ret)
                                trap_ne
354a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
354c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
354e : 48              >            pha         ;use stack to load status
354f : 28              >            plp
                        
3550 : 68                       pla             ;pull x,a
3551 : aa                       tax
3552 : 68                       pla
3553 : e8                       inx             ;return registers with modifications
3554 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3556 : 60                       rts
                                trap            ;runover protection
3557 : 4c5735          >        jmp *           ;failed anyway
                        
355a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
355d :                  nmi_trap
                                trap            ;check stack for conditions at NMI
355d : 4c5d35          >        jmp *           ;failed anyway
                        
3560 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3563 :                  res_trap
                                trap            ;unexpected RESET
3563 : 4c6335          >        jmp *           ;failed anyway
                        
3566 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
3569 : 88                       dey
356a : 88                       dey
356b :                  irq_trap                ;BRK test or unextpected BRK or IRQ
356b : 08                       php             ;either SP or Y count will fail, if we do not hit
356c : 88                       dey
356d : 88                       dey
356e : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
356f : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
3571 : f042                     beq break2
3573 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3575 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3577 : e052                     cpx #'R'
                                trap_ne        
3579 : d0fe            >        bne *           ;failed not equal (non zero)
                        
357b : c048                     cpy #'K'-3
                                trap_ne
357d : d0fe            >        bne *           ;failed not equal (non zero)
                        
357f : 850a                     sta irq_a       ;save registers during break test
3581 : 860b                     stx irq_x
3583 : ba                       tsx             ;test break on stack
3584 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
3587 : c930            >            cmp #(0      |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
3589 : d0fe            >        bne *           ;failed not equal (non zero)
                        
358b : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
358c : c930            >            cmp #(intdis |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
358e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3590 : ba                       tsx
3591 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3593 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3595 : adff01                   lda $1ff        ;propper return on stack
3598 : c909                     cmp #hi(brk_ret0)
                                trap_ne
359a : d0fe            >        bne *           ;failed not equal (non zero)
                        
359c : adfe01                   lda $1fe
359f : c9dc                     cmp #lo(brk_ret0)
                                trap_ne
35a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
35a3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
35a5 : 48                       pha
35a6 : a60b                     ldx irq_x
35a8 : e8                       inx             ;return registers with modifications
35a9 : a50a                     lda irq_a
35ab : 49aa                     eor #$aa
35ad : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
35ae : 40                       rti
                                trap            ;runover protection
35af : 4caf35          >        jmp *           ;failed anyway
                        
35b2 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
35b5 :                  break2                  ;BRK pass 2        
35b5 : e0ad                     cpx #$ff-'R'
                                trap_ne        
35b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b9 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
35bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
35bd : 850a                     sta irq_a       ;save registers during break test
35bf : 860b                     stx irq_x
35c1 : ba                       tsx             ;test break on stack
35c2 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
35c5 : c9fb            >            cmp #($ff    |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
35c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c9 : 68                       pla
35ca : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
35cc : c9fb            >            cmp #($ff    |fao)&m8i   ;I_flag is always enabled + always on bits
                        
                                trap_ne
35ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
35d0 : ba                       tsx
35d1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
35d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35d5 : adff01                   lda $1ff        ;propper return on stack
35d8 : c90a                     cmp #hi(brk_ret1)
                                trap_ne
35da : d0fe            >        bne *           ;failed not equal (non zero)
                        
35dc : adfe01                   lda $1fe
35df : c90b                     cmp #lo(brk_ret1)
                                trap_ne
35e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
35e3 : a900            >            lda #intdis&m8i         ;force enable interrupts (mask I)
                        
35e5 : 48                       pha      
35e6 : a60b                     ldx irq_x
35e8 : e8                       inx             ;return registers with modifications
35e9 : a50a                     lda irq_a
35eb : 49aa                     eor #$aa
35ed : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
35ee : 40                       rti
                                trap            ;runover protection
35ef : 4cef35          >        jmp *           ;failed anyway
                        
35f2 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zps_    db  $80,1           ;additional shift pattern to test zero result & flag
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
                        rASL_                               ;expected result ASL & ROL -carry
                        rROL_   db  0,2,$86,$04,$82,0
                        rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
                        rLSR_                               ;expected result LSR & ROR -carry
                        rROR_   db  $40,0,$61,$41,$20,0
                        rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                               ;expected flags for shifts
                        fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
                        fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
                        fLSR_
                        fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
                        fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80           ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0             ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
35b5 =                          end start
                                    
No errors in pass 2.
