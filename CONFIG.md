# Оглавление

* [Общие замечания](#общие-замечания)
* [Синтаксис описания устройств](#синтаксис-описания-устройств)
* [Устройства](#Устройства)
    * [Специальные](#Специальные)
        * [system](#system) 
        * [memory_mapper](#memory_mapper)
    * [CPU](#CPU)
        * [Общие параметры](#Общие-параметры)
        * [i8080](#i8080)
        * [Z80](#Z80)
    * [Базовые устройства](#Базовые-устройства) 
        * [ram](#ram) 
        * [rom](#rom)
        * [port](#port)
        * [port-address](#port-address)
        * [register](#register)
        * [generator](#generator)
        * [page_mapper](#page_mapper)
    * Периферия
        * [speaker](#speaker)
        * [scan-keyboard](#scan-keyboard)
        * taperecorder
        * fdd
        * i8255
        * i8257
        * i8275
        * i8253
        * wd1793
    * Машино-зависимые устройства
        * orion-128-display
        * i8275-display

# Общие замечания

* Кодировка для всех файлов &ndash; UTF-8.
* Описание конфигураций компьютеров содержится в файлах с расширением __.cfg__. Файлы должны находиться в любом подкаталоге ниже каталога __computers__.
* Эмулятор обходит все подкаталоги __computers__ и собирает общий список доступных систем. 
* Системные файлы, загружаемые из конфигурации, должны находиться в том же каталоге, что и .cfg.
* Файлы, загружаемые через интерфейс эмулятора, по умолчанию будут искаться в каталоге __software__.
* Текстовое описание конфигурации должно находиться в файле, имя которого совпадает с файлом конфигурации, но с расширением __.md__ в формате [Markdown](https://ru.wikipedia.org/wiki/Markdown).
* Файл cfg состоит из описаний устройств:
    * Первым устройством в файле должно быть устройство [__system__](#system), задающее общие параметры и описание системы.
    * Вторым устройством должен быть [CPU](#cpu), так как его частота устанавливается как основная системная.
    * Далее идут описания остальных устройств и их конфигураций. Список допустимых устройств и их параметров см. далее.
    * Также обязательным является наличие устройства [memory_mapper](#memorymapper), задающее отображение остальных устройств на адресное пространство процессора.
* Минимальный квант времени равен длительности выполнения отдельной команды.

# Синтаксис описания устройств

~~~
device_id: device_type {
    parameter1 = value
    parameter2 = value
    ~interface1 = other_device.interface3
    ~interface2[bits] = other_device.interface4[bits]
}
~~~

* Устройства соединяются друг с другом с помощью интерфейсов.
* Набор интерфейсов специфичен для каждого типа устройств.
* Если ширина интерфейса у двух устройств различна, нужно указывать диапазон подключаемых битов.
* Обычные параметры задаются как ___имя = значение___. Имена параметров и форматы значений специфичны для каждого устройства.
    * Цифровые значения можно дополнять суффиксами:
        * k: значение будет умножено на 1024.
    * Или префиксами:
        * $: число будет рассматриваться как 16-ричное. 
* Соединения интерфейсов задаются в следующем формате:
    * __~address = cpu.address__
        * Простое соединение интерфейсов одинаковой ширины.
    * __~page = portFB.value[2-3]__
        * Биты [0-1] интерфейса __page__ подключаются к битам [2-3] интерфейса __value__ устройства __portFB__;
        * Ширина интерфейса берется из правой части.

## Пример

~~~
port-user : i8255 {}

latch : register {
	~in[0-3] = port-user.B[0-3]
	~c = port-user.CH[3]
}

romdisk : rom {
	size = 512k
	image = rom512.rom
	~address[0-7] = port-user.B
	~address[8-11] = port-user.CL
	~address[12-14] = port-user.CH[0-2]
	~address[15-18] = latch.out[0-3]
	~data = port-user.A
}
~~~
* К порту на основе i8255 подключается rom-диск размером 512 Кб. Номер выбранной страницы (размером 32 Кб) хранится в регистре-защелке, которая срабатывает на установку старшего бита адреса.

# Устройства

## Специальные

### system
Основные параметры системы, раздел должен быть первым в файле.
~~~
system { 
	type = type_id
	name = type_name_for_display
	version = version_name_for_display
	charmap = character_map_file 
	screenratio = screen_ration
	screenscale = screen_scale
	files = file_types_to_select
}
~~~

* __type*__: Идентификатор типа компьютера. Используется для сбора конфигураций в группы в диалоге выбора.
* __name*__: Эквивалент type, отображается в интерфейсе.
* __version*__: Вариант исполнения. Выводится вторым уровнем в дереве выбора конфигурации.
* __charmap*__: Файл с отображением кодировки на UTF-8. Должен состоять из 256 символов UTF-8, где номер символа &ndash; его код в исходном компьютере.
    * Таблица используется в окнах дампов и отладчике.
    * Символы можно делить на группы переводами строки, которые при обработке игнорируются.
    * Файлы кодировок находятся в каталоге __data__ и имеют расширение __.chr__.
* __screenratio__: Соотношение сторон пикселя при выводе на экран. Используется, чтобы подогнать экран под соотношение 4:3 независимо от разрешения эмулируеумого компьютера.
* __screenscale__: Масштабирование экрана. Актуально для больших современных мониторов.
* __files__: Фильтр, который будет использоваться в диалоге выбора файлов для загрузки.

### Пример

~~~
system { 
	type = orion-128
	name = Орион-128
	version = Z80 Card II / Тест
	charmap = radio-86rk 
	screenratio = 1
	screenscale = 2
	files = "Файлы Орион-128 (*.bru; *.ord; *.rko)|*.bru; *.ord; *.rko"
}
~~~

### memory_mapper

Главный диспетчер адресного пространства процессора.

~~~
mapper : memory_mapper {
	portstomemory = 0
	cancelinit = $8000
	config = port1

	@memory[*][$0000-$07FF] = bios {mode = r}
	@memory[value:mask][addr1-addr2] = device
	@memory[addr1-addr2] = device[start_addr]

	@port[number] = device
}
~~~

В конфигурации Memory Mapper три основных раздела:

* Основные параметры:
    * __portstomemory__ (0/1): Отображение портов на память. По умолчанию &ndash; 0;
    * __wideports__ (0/1): Разрядность номеров портов (8/16). По умолчанию &ndash; 8;
    * __cancelinit__: При получении какого адреса отменится запись ___@memory[*]___. Обычно используется для отображения системного ПЗУ на начальные адреса памяти после сброса.
    * __config__: Устройство (порт), содержащее регистр конфигурации диспетчера. Значения этого регистра используются в записях ___@memory___.
* Отображение адресов памяти. Поиск подходящего условия происходи сверху вниз, поэтому первые строки имеют приоритет. Примеры записей:
    * __@memory[$0000-$7FFF] = ram__
        * Диапазон памяти $0000-$7FFF безусловно отображается на устройство __ram__;
    * __@memory[*][$0000-$07FF] =  bios {mode = r}__
        * Диапазон памяти $0000-$07FF после сброса отображается на устройство __bios__ при операциях чтения;
        * После получения адреса с маской __cancelinit__ эта запись блокируется;
        * Данная запись должна быть первой в списке, чтобы иметь приоритет над остальными.
    * __@memory[$E000-$FFFF] = dma {mode = w}__
        * Диапазон памяти $E000-$FFFF отображается на устройство __dma__ при операциях записи;
    * __@memory[$F700-$F72F] = fdc {mode = w, addr_mask=$24, addr_value=0}__
        * Диапазон $F700-$F72F отображается на устройство __fdc__ при операциях записи, дополнительно адрес при наложении AND-маски $24 должен давать 0.
    * __@memory[0][$0000-$EFFF] = ram0__
	* __@memory[1][$0000-$EFFF] = ram1__
        * В зависимости от значения порта __config__ выбирается одна из страниц памяти.
    * __@memory[$00:$20][$F000-$F3FF] = ram0[$F000]__
	* __@memory[$20:$20][$F000-$F3FF] = mm3[$F000]__
        * В зависимости от значения отдельного бита config [value:mask] диапазон отображается либо на страницу памяти, либо на страничный менеджер. Начальный адрес на устройствах &ndash; $F000; 
* Распределение портов (при отключенном отображении на память).
    * __@port[$F4] = port-keyboard__
        * Порт $F4 отображается на устройство __port-keyboard__.

## CPU
### Общие параметры
~~~
cpu : z80 {
	clock = 5000000
}
~~~
* __clock__: Частота процессора, Гц. Также становится первичной частотой для всей системы.

### i8080

### z80

## Базовые устройства

### ram
Блок ОЗУ
~~~
ram0 : ram {
	size = 64k
	fill = 0
}
~~~
* __size*__: Размер в байтах.
* __fill__: Байт для заполнения при холодном сбросе. По умолчанию &ndash; 0.

### rom
Блок ПЗУ
~~~
bios : rom {
	size=2k
	image=TestZ80.bin
}
~~~
* __size*__: Размер в байтах.
* __fill__: Байт для заполнения пустой области. По умолчанию &ndash; $FF.
* __image*__: Имя файла образа:
    * Поддерживаются форматы [Intel Hex](https://ru.wikipedia.org/wiki/Intel_HEX) (*.hex), двоичный (другие расширения).
    * Файл *.hex будет загружен с начального адреса на устройстве, независимо от указанного в самом файле.
    * Размер файла должен быть меньше или равен __size__. Остаток будет заполнен байтом __fill__.
    * Файл должен находиться в том же каталоге, что и .cfg.

### port
Единичный адресуемый регистр/порт
~~~
port-videomode: port {}
~~~
* Параметры:
    * __size__: Ширина регистра в битах. По умолчанию &ndash; 8;
    * __flipmask__: Маска для инверсии значения по отрицательному фронту интерфейса __flip__. По умолчанию &ndash; $FFFFFFFF.
* Интерфейсы:
    * __value[8]__: Выходные данные.
    * __access[1]__: Выдает импульс отрицательной полярности в момент записи значения.
    * __flip[1]__: При отрицательном фронте по этому интерфейсу происходит инверсия значения порта по маске __flipmask__. 

### port-address
Единичный адресуемый регистр/порт, запоминающий адрес обращения, а не данные.
~~~
port-video: port-address {}
~~~
* Параметры и интерфейсы аналогично __port__.

### register
Регистр-защелка. Запоминает входное значение по стробу на входе записи.
~~~
latch : register {
	~in[0-3] = port-user.B[0-3]
	~c = port-user.CH[3]
}
~~~
Интерфейсы:
* __in[16]__: Входные данные.
* __c[1]__: Строб записи (положительный фронт).
* __out[16]__: Выход записанных данных. 

### generator
Генератор импульсов заданной частоты
~~~
gen50hz: generator {
	frequency = 50
	polarity = positive
	length = 1
}
~~~
* __frequency*__: Частота импульсов, Гц. 
* __polarity__: Полярность импульсов. Значения: _positive_, _pos_, _p_, _1_, _negative_, _neg_, _n_, _0_). Значение по умолчанию: _positive_.
* __length__: Длина импульса в отсчетах системного генератора. Значение по умолчанию: 1.
    * В связи с особенностями эмуляции, минимально возможная длина импульса фактически будет равна длине команды CPU, на которую он попадет.

### page_mapper
Страничный диспетчер
~~~
mm2 : page_mapper {
	frame = 16k
	@page[0] = ram0
	@page[1] = ram1
	@page[2] = ram2
	@page[3] = ram3
	~page    = portFB.value[2-3]
	~segment = portFB.value[0-1]
}
~~~
Параметры:
* __frame__: Размер сегмента страницы памяти, а также выходного окна. По умолчанию равен размеру страницы.
* __@page[]__: Перечень устройств-страниц.

Интерфейсы:
* __page*__: Номер выбранной страницы.
* __segment__: Номер сегмента в странице.

Если сегментирование страниц не используется, __frame__ и __~segment__ не указываются. 

Количество страниц и сегментов должно соответствовать ширине соответствующих интерфейсов. В данном примере 4 страницы размером по 64кб, в каждой 4 сегмента по 16к, что соответствует двум двухбитным интерфейсам.

### speaker
Однобитный спикер
~~~
sound : speaker {
	~input = cpu.inte
	~mixer[0-2] = timer.output[0-2]
}
~~~
Интерфейсы:
* __input[1]__: Вход однобитного спикера.
* __mixer[8]__: Вход для нескольких однобитных каналов.

__Примечания__:
* Должно быть создано как минимум одно соединение интерфейса __input__ либо __mixer__. Все использованные входы микшируются пропорционально.
* Чтобы работал регулятор громкости, устройство должно называться __sound__.

### scan-keyboard
Клавиатура с матрицей сканирования
~~~
keyboard : scan-keyboard {
	~scan = port-keyboard.A
	~output = port-keyboard.B
	~shift = port-keyboard.CH[5]
	~ctrl = port-keyboard.CH[6]
	~ruslat = port-keyboard.CH[7]
	@layout = {
		home		tab  		0 	8 	~ 	H 	P 	X
		del|del2	ret2 		1 	9 	A 	I 	Q 	Y
		esc 		ret		2 	" 	B 	J 	R 	Z
		F1		back		3	;	C	K	S 	[
		F2		left		4	,	D	L	T	\
		F3		up		5	-	E	M	U	]
		F4		right		6	.	F	N	V	div
		__		down		7	/	G	O	W	space
	}
	ctrl = ctrl
	shift = shift
	ruslat = caps
}
~~~
Параметры:
* __ctrl__: Назначение кнопки Control.
* __shift__: Назначение кнопки Shift.
* __ruslat__: Назначение кнопки переключения Рус-Лат.

Интерфейсы:
* __scan__: Линии сканирования.
* __output__: Выходные линии.
* __shift__: Линия Shift;
* __ctrl__: Линия Control;
* __ruslat__: Линия Рус-Лат;

Раскладка задается в параметре @layout в виде таблицы соответствия клавиш. Каждая строка соответствует линии сканирования. Каждый столбец &ndash; выходной линии.

Несколько клавиш можно указывать через знак "|". Значения разделяются пробелом или табуляцией.

Доступные клавиши:
* 0..9, A..Z, f1..f12
* pgup, pgdown, end, home, left, right, up, down
* ret, ret2, caps, esc, space, back, ins, del, del2
* mult, plus, minus, div, num, scroll 
* ~ - = \ [ ] ; " / , .
* __ (двойное подчеркивание) &ndash; клавиша в этой позиции отсутствует.
